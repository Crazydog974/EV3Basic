<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
<HEAD>
<meta charset="utf-8"/>
<TITLE>EV3-Basic Benutzerhandbuch</TITLE>
<style type="text/css">
  H1.chapter {
	margin-top: 100px;
    font-family: Verdana; 
  }
  H3.subchapter {
    font-family: Verdana; 
  }
  P {
    font-family: Verdana; 
  }
  UL {
    font-family: Verdana; 
  }
  ADDRESS {
    font-family: Verdana; 
	float: right;
  }
  TABLE {
    font-family: Verdana;
	border-spacing: 0px;
	border:1px solid black;
  }
  TD {
	padding: 4px;
  }
  TR:nth-child(1)
  {
	background: #d0d0d0;
  } 
  TD:nth-child(1)
  {
	background: #d0d0d0;
  } 

  H2.object {
    font-family: Verdana; 
	border-bottom: medium solid;
  }
  P.objectsummary {
    font-family: Verdana; 
  }
  H3.operation {
    font-family: Verdana;  
	margin-top: 20px;
	margin-bottom: 10px;
	margin-left: 20px; 
  }
  P.operationsummary {
    font-family: Verdana; 
	margin-top: 10px;
	margin-bottom: 10px;
	margin-left: 20px; 
  }
  H3.property {
    font-family: Verdana;  
	margin-top: 20px;
	margin-bottom: 10px;
	margin-left: 20px; 
  }
  P.propertysummary {
    font-family: Verdana; 
	margin-top: 10px;
	margin-bottom: 10px;
	margin-left: 20px; 
  }
  H4.parameter {
    font-family: Verdana; 
	margin-top: 0px;
	margin-bottom: 0px;
	margin-left: 50px; 
  }
  P.parametersummary {
    font-family: Verdana;
	margin-top: 0px;
	margin-bottom: 10px;
	margin-left: 50px; 
  }
  H4.returns {
    font-family: Verdana; 
	margin-top: 0px;
	margin-bottom: 0px;
	margin-left: 50px; 
  }
  P.returnssummary {
    font-family: Verdana;
	margin-top: 0px;
	margin-bottom: 10px;
	margin-left: 50px; 
  }
</style>

</HEAD>
<BODY>
Das Handbuch auf Deutsch

<H2 class="object">Assert</H2>
<P class="objectsummary">Das Assert-Objekt unterstützt dich dabei, Teile des Programmes auf Korrektheit zu überprüfen.<BR>Eine 'Assertion' macht implizite Annahmen über das Programmverhalten explizit. Durch hinzufügen von Assertions, kannst du Fehler im Programm leicher finden. Wenn zum Beispiel ein Teil des Programmes davon ausgeht, dass die Variable A einen positiven Wert hat, dann kannst du das mit  Assert.Greater(A,0,"A muss > 0 sein!") an dieser Stelle überprüfen. <BR>Falls das Programm auf eine Assertion trifft, die nicht erfüllt ist, wird eine entsprechende Fehlermeldung im Textfenster oder am Bildschirm des EV3 ausgegebeben.</P>
<H3 class="operation">Assert.Equal (a, b, message)</H3>
<P class="operationsummary">Prüft, ob zwei Werte völlig identisch sind. Bei diesem Test gelten sogar "True" und "tRue" als verschieden.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.Failed (message)</H3>
<P class="operationsummary">Gibt eine Fehlermeldung am Bildschirm aus. Dieser Befehl soll nur verwendet werden, wenn bereits ein Fehler erkannt wurde.</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben werden soll</P>
<H3 class="operation">Assert.Greater (a, b, message)</H3>
<P class="operationsummary">Prüft, ob der erste Wert größer als der zweite Wert ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.GreaterEqual (a, b, message)</H3>
<P class="operationsummary">Prüft, ob der erste Wert größer als der zweite Wert oder gleich ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.Less (a, b, message)</H3>
<P class="operationsummary">Prüft, ob der erste Wert kleiner als der zweite Wert ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.LessEqual (a, b, message)</H3>
<P class="operationsummary">Prüft, ob der erste Wert kleiner als der zweite Wert oder gleich ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.Near (a, b, message)</H3>
<P class="operationsummary">Prüft, ob zwei Werte gleich beziehungsweise fast gleich sind. 'Fast gleich' bedeutet, dass ein geringer Unterschied, der eventuell durch Rundungsfehler entstanden ist, auch noch zulässig ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.NotEqual (a, b, message)</H3>
<P class="operationsummary">Prüft, ob zwei Werte verschieden sind. Bei diesem Test gelten sogar "True" und "tRue" als verschieden.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H2 class="object">Buttons</H2>
<P class="objectsummary">Dieses Objekt liest den Zustand der Tasten und die letzten Tastendrücke.<BR>Die Tasten werden mit den folgenden Buchstaben angesprochen:<BR>U   Hinauf<BR>D   Hinunter<BR>L   Links<BR>R   Rechts<BR>E   Mittlere Taste</P>
<H3 class="property">Buttons.Current - property</H3>
<P class="propertysummary">Liest alle Tasten, die gedrückt sind. <BR>Diese Eigenschaft enthält die Buchstaben für alle Tasten, die jetzt gerade in diesem Moment niedergedrückt sind.</P>
<H3 class="operation">Buttons.Flush ()</H3>
<P class="operationsummary">Löscht alle gespeicherten Tastendrücke. Spätere Aufrufe von GetClicks liefern nur mehr die Tasten, die nach dem Flush gedrückt wurden.</P>
<H3 class="operation">Buttons.GetClicks ()</H3>
<P class="operationsummary">Erkennt, welche Tasten in der Zeit seit dem letzten Aufruf von GetClicks am Brick gedrückt wurden.<BR>Der 'gedrückt' - Zustand der Tasten wird dabei gelöscht. Außerdem wird automatisch ein Klick-Geräusch erzeugt, wenn ein Tastendruck erkannt wurde.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Ein Text der die Buchstaben aller gedrückten Tasten enthält (kann auch leer sein)</P>
<H3 class="operation">Buttons.Wait ()</H3>
<P class="operationsummary">Wartet bis zumindest eine Taste am Brick gedrück wird. Falls eine Taste bereits vorher gedrück war und der Tastendruck noch nicht mit GetClicks abgeholt wurde, dann kehrt dieser Befehl sofort zurück.</P>
<H2 class="object">EV3</H2>
<P class="objectsummary">Nützliche kleine Funktionen für verschiedene Teile des EV3-Bricks.</P>
<H3 class="property">EV3.BatteryLevel - property</H3>
<P class="propertysummary">Aktueller Ladezustand der Batterie in Prozent (Wertebereich 0 bis 100).</P>
<H3 class="property">EV3.Time - property</H3>
<P class="propertysummary">Die Zeit in Millisekunden seit dem Start des Programmes.</P>
<H3 class="operation">EV3.QueueNextCommand ()</H3>
<P class="operationsummary">Reduziert den Kommunikationsaufwand, wenn das Programm am PC läuft und den EV3 fernsteuert: Das nächste Kommando wird nicht sofort an den EV3 geschickt, sondern erst wenn noch ein weiteres Kommando geschickt werden muss. Man kann das Abschicken mit weiteren QueueNextCommand - Befehlen noch weiter verzögern, um möglichst viele Befehle als ganzen Block auf einmal zu schicken. <BR>Wenn das Programm direkt am EV3 läuft, hat dieser Befehl keine Auswirkung.</P>
<H3 class="operation">EV3.SetLEDColor (color, effect)</H3>
<P class="operationsummary">Setzt die Farbe der Tasten-Beleuchtung und einen der optischen Effekte.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">Eines der folgenden: "OFF", "GREEN", "RED", "ORANGE"</P>
<H4 class="parameter">effect</H4>
<P class="parametersummary">Eines der folgenden: "NORMAL", "FLASH", "PULSE"</P>
<H3 class="operation">EV3.SystemCall (commandline)</H3>
<P class="operationsummary">Führt einen externen Befehl das Linux-Systems aus. Alle Threads des Basic-Programmes werden so lange angehalten, bis der Systembefehl beendet ist. <BR>Um das vernünftig benutzen zu können, benötigt man entsprechende Linux-Kenntnisse.</P>
<H4 class="parameter">commandline</H4>
<P class="parametersummary">Auszuführendes Systemkommando.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Exit-Status des Kommandos.</P>
<H2 class="object">EV3File</H2>
<P class="objectsummary">EV3File dient zum Ansprechen des Dateisystems auf dem Brick um Daten zu lesen und zu schreiben.<BR>Dateinamen können entweder absolut (mit führendem '/') oder relativ zum 'prjs'-Verzeichnis sein.</P>
<H3 class="operation">EV3File.Close (handle)</H3>
<P class="operationsummary">Schließt eine offene Datei.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H3 class="operation">EV3File.ConvertToNumber (text)</H3>
<P class="operationsummary">Befehl um einen Text in eine Zahl zu konvertieren.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Ein Text, der die dezimale Darstellung einer Zahl (mit optionalen Nachkommastellen) enthält.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die Zahl</P>
<H3 class="operation">EV3File.OpenAppend (filename)</H3>
<P class="operationsummary">Öffnet eine Datei zum Hinzufügen von Dateien. Falls die Datei noch nicht existiert, wird sie angelegt.</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei, die erweitert bzw. angelegt werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Eine Nummer mit der die offene Datei später angesprochen wird.</P>
<H3 class="operation">EV3File.OpenRead (filename)</H3>
<P class="operationsummary">Öffnet eine Datei zum Lesen. Falls die Datei nicht existiert, wird 0 zurückgeben.</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei von der gelesen werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Eine Nummer mit der die offene Datei später angesprochen wird, oder 0 falls die Datei nicht existiert.</P>
<H3 class="operation">EV3File.OpenWrite (filename)</H3>
<P class="operationsummary">Öffnet eine Datei zum Schreiben. Falls die Datei schon existiert, wird sie überschrieben.</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei die angelegt bzw. überschrieben werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Eine Nummer mit der die offene Datei später angesprochen wird.</P>
<H3 class="operation">EV3File.ReadByte (handle)</H3>
<P class="operationsummary">Liest ein einzelnes Byte aus einer Datei.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Das nächste Byte aus der Datei.</P>
<H3 class="operation">EV3File.ReadLine (handle)</H3>
<P class="operationsummary">Liest eine Zeile Text aus einer Datei. Der Text wird bis zum Zeilenumbruch (code 10) aus der Datei gelesen und entsprechend ISO-8859-1 dekodiert.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Text, der aus der Datei gelesen wurde.</P>
<H3 class="operation">EV3File.ReadNumberArray (handle, size)</H3>
<P class="operationsummary">Liest ein ganzes Array von Zahlen im Binärformat aus einer Datei. Die Zahlen müssen als einfache IEEE-Fließkommazahlen (4 Byte pro Zahl) in der Datei vorliegen.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H4 class="parameter">size</H4>
<P class="parametersummary">Anzahl der Zahlen, die gelesen werden sollen.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Ein Array mit den gelesenen Zahlen.</P>
<H3 class="operation">EV3File.TableLookup (filename, bytes_per_row, row, column)</H3>
<P class="operationsummary">Hilfsfunktion um aus einer möglicherweise extrem großen Datei ein einzelnes Byte herauszulesen.<BR>Weil die Datei so groß sein kann, dass der Wertebereich normaler vom EV3 unterstützter Zahlen nicht mehr ausreicht, um alle Bytes zu adressieren, ist es möglich die Datei mit einer Zeilen/Spalten-Adressierung anzusprechen.</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Der Name der Datei.</P>
<H4 class="parameter">bytes_per_row</H4>
<P class="parametersummary">Wenn man eine Zeilen/Spalten-Adressierung verwenden will, ist das die Länge der einzelnen Zeilen. Ansonsten muss man hier 1 verwenden um jedes Byte als eigene Zeile zu interpretieren.</P>
<H4 class="parameter">row</H4>
<P class="parametersummary">Welche Zeile soll genommen werden (start bei 0)?</P>
<H4 class="parameter">column</H4>
<P class="parametersummary">Welche Spalte soll genommen werden (start bei 0)?</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Das Byte an der gewünschten Stelle.</P>
<H3 class="operation">EV3File.WriteByte (handle, data)</H3>
<P class="operationsummary">Schreibt ein einzelnes Byte in die Datei.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H4 class="parameter">data</H4>
<P class="parametersummary">Ein Byte, das geschrieben werden soll (Eine Zahl von 0 bis 255).</P>
<H3 class="operation">EV3File.WriteLine (handle, text)</H3>
<P class="operationsummary">Schreibt eine Zeile Text in die Datei. Der Text wird entsprechend ISO-8859-1 kodiert und mit einem Zeilenumbruch (code 10) abgeschlossen.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, der geschrieben werden soll.</P>
<H2 class="object">LCD</H2>
<P class="objectsummary">Steuert die LCD-Anzeige am Brick.<BR>Der EV3 hat eine schwarz-weiße Anzeige mit 178x128 Pixel. Alle Pixel werden mit X,Y-Koordinaten angesprochen, wobei X=0 der linke Rand und Y=0 der obere Rand ist.</P>
<H3 class="operation">LCD.BmpFile (color, x, y, filename)</H3>
<P class="operationsummary">Zeichnet ein Bild aus einer Datei. Nur Dateien im .rgf-Format werden unterstützt.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (normal) oder 1 (invertiert)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate der linken Kante</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate der oberen Kante</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei ohne die .rgf - Erweiterung. Dieser Dateiname kann relativ zum 'prjs'-Verzeichnis oder ein absoluter Name (mit führendem '/') sein.</P>
<H3 class="operation">LCD.Circle (color, x, y, radius)</H3>
<P class="operationsummary">Zeichnet einen Kreis in einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate des Mittelpunkts</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate des Mittelpunkts</P>
<H4 class="parameter">radius</H4>
<P class="parametersummary">Radius des Kreises</P>
<H3 class="operation">LCD.Clear ()</H3>
<P class="operationsummary">Setzt alle Pixel der Anzeige auf Weiß.</P>
<H3 class="operation">LCD.FillCircle (color, x, y, radius)</H3>
<P class="operationsummary">Füllt einen Kreis mit einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate des Mittelpunkts</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate des Mittelpunkts</P>
<H4 class="parameter">radius</H4>
<P class="parametersummary">Radius des Kreises</P>
<H3 class="operation">LCD.FillRect (color, x, y, width, height)</H3>
<P class="operationsummary">Füllt ein Rechteck mit einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">Linke Kante des Rechtecks</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Obere Kante des Rechtecks</P>
<H4 class="parameter">width</H4>
<P class="parametersummary">Breite des Rechtecks</P>
<H4 class="parameter">height</H4>
<P class="parametersummary">Höhe des Rechtecks</P>
<H3 class="operation">LCD.InverseRect (x, y, width, height)</H3>
<P class="operationsummary">Invertiert die Farbe aller Pixel innerhalb eines Rechtecks.</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">Linke Kante des Rechtecks</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Obere Kante des Rechtecks</P>
<H4 class="parameter">width</H4>
<P class="parametersummary">Breite des Rechtecks</P>
<H4 class="parameter">height</H4>
<P class="parametersummary">Höhe des Rechtecks</P>
<H3 class="operation">LCD.Line (color, x1, y1, x2, y2)</H3>
<P class="operationsummary">Zeichnet eine gerade Linie von Pixel mit einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x1</H4>
<P class="parametersummary">X-Koordinate des Startpunkts</P>
<H4 class="parameter">y1</H4>
<P class="parametersummary">Y-Koordinate des Startpunkts</P>
<H4 class="parameter">x2</H4>
<P class="parametersummary">X-Koordinate des Endpunkts</P>
<H4 class="parameter">y2</H4>
<P class="parametersummary">Y-Koordinate des Endpunkts</P>
<H3 class="operation">LCD.Pixel (color, x, y)</H3>
<P class="operationsummary">Setzt die Farbe eines einzelnen Pixels auf der Anzeige.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate</P>
<H3 class="operation">LCD.Rect (color, x, y, width, height)</H3>
<P class="operationsummary">Zeichnet den Umriss eines Rechtecks in einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">Linke Kante des Rechtecks</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Obere Kante des Rechtecks</P>
<H4 class="parameter">width</H4>
<P class="parametersummary">Breite des Rechtecks</P>
<H4 class="parameter">height</H4>
<P class="parametersummary">Höhe des Rechtecks</P>
<H3 class="operation">LCD.StopUpdate ()</H3>
<P class="operationsummary">Verhindert, dass nachfolgende Ausgabebefehle sofort auf die Anzeige zeichnen und speichert die Änderungen zuerst nur.<BR>Beim nächsten Aufruf von Update werden die Änderungen schließlich auf einmal zur Anzeige gebracht. Dieser Befehl kann nützlich sein, um Bildschirmflackern zu verhindern oder die Ausgabe zu beschleunigen.</P>
<H3 class="operation">LCD.Text (color, x, y, font, text)</H3>
<P class="operationsummary">Schreibt einen Text (oder eine Zahl) in einer Größe und Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate wo der Text anfangen soll</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate wo der Text anfangen soll</P>
<H4 class="parameter">font</H4>
<P class="parametersummary">Schriftgröße: 0 (winzig), 1 (klein), 2 (groß)</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text (oder die Zahl) die geschrieben werden soll</P>
<H3 class="operation">LCD.Update ()</H3>
<P class="operationsummary">Zeichnet alle Änderungen seit dem letzten StopUpdate auf die Anzeige.<BR>Nach Update() werden wieder alle Änderungen sofort auf die Anzeige gebracht, außer man benutzt StopUpdate ein weiteres mal.</P>
<H3 class="operation">LCD.Write (x, y, text)</H3>
<P class="operationsummary">Schreibt einen Text (oder eine Zahl) in mittlerer Größe und schwarzer Farbe.</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate wo der Text anfangen soll</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate wo der Text anfangen soll</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text (oder die Zahl) die geschrieben werden soll</P>
<H2 class="object">Mailbox</H2>
<P class="objectsummary">Kommunikationsystem um Daten von einem EV3-Brick zu einem anderen über Bluetooth-Funk zu übertragen.</P>
<H3 class="operation">Mailbox.Connect (brickname)</H3>
<P class="operationsummary">Versucht, eine Verbindung zu einem anderen EV3-Brick aufzubauen.<BR>Nur wenn eine Verbindung geöffnet wurde (entweder mit diesem Befehl oder von Hand mit dem Menu am Brick), können Nachrichten ausgetauscht werden.</P>
<H4 class="parameter">brickname</H4>
<P class="parametersummary">Name des anderen Bricks.</P>
<H3 class="operation">Mailbox.Create (boxname)</H3>
<P class="operationsummary">Erzeugt einen Briefkasten für ankommenden Nachrichten auf dem Brick. <BR>Erst wenn solch ein Briefkasten angelegt wurde, können Nachrichten empfangen werden.<BR>Maximal 30 Briefkästen können auf einem Brick existieren.</P>
<H4 class="parameter">boxname</H4>
<P class="parametersummary">Name des neuen Briefkastens</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Eine Identifikationsnummer für den Briefkasten. Sie wird benötigt um später Nachrichten herauszuholen</P>
<H3 class="operation">Mailbox.IsAvailable (id)</H3>
<P class="operationsummary">Prüft, ob bereits eine Nachricht im Briefkasten ist.</P>
<H4 class="parameter">id</H4>
<P class="parametersummary">Identifikationsnummer des lokalen Briefkastens.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">"True", falls bereits eine Nachricht vorliegt. Sonst "False".</P>
<H3 class="operation">Mailbox.Receive (id)</H3>
<P class="operationsummary">Entfernt und holt die älteste Nachricht aus dem Briefkasten. Wenn noch keine Nachricht vorhanden ist, blockiert dieser Befehl so lange, bis eine Nachricht eintrifft.<BR>Wenn man blockierendes Warten vermeiden will, kann man zuvor mit IsAvailable() prüfen, ob eine Nachricht da ist.<BR>Falls gar kein Briefkasten mit der Identifikationsnummer existiert, liefert der Befehl sofort "".</P>
<H4 class="parameter">id</H4>
<P class="parametersummary">Identifikationsnummer des Briefkastens</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die Nachricht als einfacher Text. Derzeit werden keine anderen Nachrichtenformate unterstützt.</P>
<H3 class="operation">Mailbox.Send (brickname, boxname, message)</H3>
<P class="operationsummary">Sended eine Nachricht an einen Briefkasten eines anderen EV3-Bricks.</P>
<H4 class="parameter">brickname</H4>
<P class="parametersummary">Der Name des Bricks, der die Nachricht empfangen soll. Zuvor muss eine Verbindung zu diesem Brick geöffnet worden sein. Es ist auch möglich, einen Leertext als Namen anzugeben. In diesem Fall wird die Nachricht an alle verbundenen Bricks geschickt.</P>
<H4 class="parameter">boxname</H4>
<P class="parametersummary">Name des Briefkastens in dem die Nachricht gespeichert werden soll.</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Die Nachricht als einfacher Text. Derzeit werden keine anderen Nachrichtenformate unterstützt.</P>
<H2 class="object">Math</H2>
<P class="objectsummary">Das Math-Objekt stellt zahlreiche nützliche mathematische Methoden zur Verfügung</P>
<H3 class="property">Math.Pi - property</H3>
<P class="propertysummary">Gibt den Wert der Zahl Pi zurück</P>
<H3 class="operation">Math.Abs (number)</H3>
<P class="operationsummary">Ruft den absoluten Wert einer Zahl ab. Zum Beispiel gibt -32.233 den Wert 32.233 zurück.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, für die der absolute Wert abgerufen werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der absolute Wert einer Zahl.</P>
<H3 class="operation">Math.ArcCos (cosValue)</H3>
<P class="operationsummary">Ermittelt den Bogenmaßwinkel anhand des Kosinuswertes.</P>
<H4 class="parameter">cosValue</H4>
<P class="parametersummary">Der Kosinuswert, dessen Winkel benötigt wird.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Bogenmaßwinkel für den gegebenen Kosinuswert.</P>
<H3 class="operation">Math.ArcSin (sinValue)</H3>
<P class="operationsummary">Ermittelt den Bogenmaßwinkel anhand des Sinuswertes.</P>
<H4 class="parameter">sinValue</H4>
<P class="parametersummary">Der Sinuswert, dessen Winkel benötigt wird.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Bogenmaßwinkel für den gegebenen Sinuswert.</P>
<H3 class="operation">Math.ArcTan (tanValue)</H3>
<P class="operationsummary">Ermittelt den Bogenmaßwinkel anhand des Tangenswertes.</P>
<H4 class="parameter">tanValue</H4>
<P class="parametersummary">Der Tangenswert, dessen Winkel benötigt wird.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Bogenmaßwinkel für den gegebenen Tangenswert.</P>
<H3 class="operation">Math.Ceiling (number)</H3>
<P class="operationsummary">Ruft eine Ganzzahl ab, die den gleichen Wert wie die angegebene Dezimalzahl hat oder größer als diese ist. Zum Beispiel gibt 32.233 den Wert 33 zurück.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, deren größter Wert erforderlich ist.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der größte Wert einer Zahl.</P>
<H3 class="operation">Math.Cos (angle)</H3>
<P class="operationsummary">Ermittelt den Kosinus des angegebenen Winkels im Bogenmaß.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel (im Bogenmaß), dessen Kosinus benötigt wird.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Kosinus des gegebenen Winkels.</P>
<H3 class="operation">Math.Floor (number)</H3>
<P class="operationsummary">Ruft eine Ganzzahl ab, die den gleichen Wert wie die angegebene Dezimalzahl hat oder kleiner als diese ist. Zum Beispiel gibt 32.233 den Wert 32 zurück.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, deren kleinster Wert erforderlich ist.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der kleinste Wert einer Zahl.</P>
<H3 class="operation">Math.GetDegrees (angle)</H3>
<P class="operationsummary">Rechnet einen Winkel im Bogenmaß in Gradmaß um.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel im Bogenmaß.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der umgewandelte Winkel in Grad.</P>
<H3 class="operation">Math.GetRadians (angle)</H3>
<P class="operationsummary">Rechnet einen Winkel im Gradmaß in Bogenmaß um.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel in Grad.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der umgewandelte Winkel im Bogenmaß.</P>
<H3 class="operation">Math.GetRandomNumber (maxNumber)</H3>
<P class="operationsummary">Liefert eine Zufallszahl zwischen 1 und der gegebenen Zahl (inklusive).</P>
<H4 class="parameter">maxNumber</H4>
<P class="parametersummary">Die Obergrenze für die angeforderte Zufallszahl.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Eine Zufallszahl die kleiner oder gleich der spezifiziert Zahl ist.</P>
<H3 class="operation">Math.Log (number)</H3>
<P class="operationsummary">Ermittelt den Logarithmus zur Basis 10 der angegebenen Zahl.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, deren Logarithmus ermittelt werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Logarithmus der angegebenen Zahl</P>
<H3 class="operation">Math.Max (number1, number2)</H3>
<P class="operationsummary">Vergleicht zwei Zahlen und gibt die größere der beiden zurück.</P>
<H4 class="parameter">number1</H4>
<P class="parametersummary">Die erste von zwei zu vergleichenden Zahlen.</P>
<H4 class="parameter">number2</H4>
<P class="parametersummary">Die zweite von zwei zu vergleichenden Zahlen.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die Größere der zwei Zahlen.</P>
<H3 class="operation">Math.Min (number1, number2)</H3>
<P class="operationsummary">Vergleicht zwei Zahlen und gibt die kleinere der beiden zurück.</P>
<H4 class="parameter">number1</H4>
<P class="parametersummary">Die Erste von zwei zu vergleichenden Zahlen.</P>
<H4 class="parameter">number2</H4>
<P class="parametersummary">Die Zweite von zwei zu vergleichenden Zahlen.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die Kleinere der zwei Zahlen.</P>
<H3 class="operation">Math.NaturalLog (number)</H3>
<P class="operationsummary">Ermittelt den natürlichen Logarithmus der angegebenen Zahl.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, deren natürlicher Logarithmuswert erforderlich ist.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der natürliche Logarithmuswert einer Zahl.</P>
<H3 class="operation">Math.Power (baseNumber, exponent)</H3>
<P class="operationsummary">Berechnet die angegebene Potenz der Zahl baseNumber.</P>
<H4 class="parameter">baseNumber</H4>
<P class="parametersummary">Die Zahl, deren Potenz berechnet werden soll.</P>
<H4 class="parameter">exponent</H4>
<P class="parametersummary">Der Exponent, der bei der Berechnung der Potenz verwendet werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die angebenene Potenz der Zahl baseNumber.</P>
<H3 class="operation">Math.Remainder (dividend, divisor)</H3>
<P class="operationsummary">Teilt die erste Zahl durch die zweite Zahl und gibt den Rest zurück.</P>
<H4 class="parameter">dividend</H4>
<P class="parametersummary">Die zu teilende Zahl.</P>
<H4 class="parameter">divisor</H4>
<P class="parametersummary">Die Zahl durch die geteilt werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Divisionsrest.</P>
<H3 class="operation">Math.Round (number)</H3>
<P class="operationsummary">Rundet eine gegebene Zahl auf die nächstliegende ganze Zahl. Die Zahl 32.233 wird zum Beispiel auf 32.0 abgerundet, während <BR>32.566 auf 33 aufgerundet wird.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl dessen Näherungswert benötigt wird.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der gerundete Wert der gegebenen Zahl.</P>
<H3 class="operation">Math.Sin (angle)</H3>
<P class="operationsummary">Ermittelt den Sinus des angegebenen Winkels im Bogenmaß.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel (im Bogenmaß), dessen Sinus ermittelt werden soll</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Sinus des angegebenen Winkels</P>
<H3 class="operation">Math.SquareRoot (number)</H3>
<P class="operationsummary">Ermittelt die Quadratwurzel einer angegebenen Zahl.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl dessen Quadratwurzel benötigt wird.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die Quadratwurzel der gegebenen Zahl.</P>
<H3 class="operation">Math.Tan (angle)</H3>
<P class="operationsummary">Ermittelt den Tangens des angegebenen Winkels im Bogenmaß.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel (im Bogenmaß), dessen Tangens benötigt wird.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Tangens des gegebenen Winkels.</P>
<H2 class="object">Motor</H2>
<P class="objectsummary">Steuert die angeschlossenen Motoren.<BR>Bei jedem Befehl muss man einen oder mehrere Motor-Ports angeben, auf den sich der Befehl beziehen soll (zum Beispiel, "A", "BC", "ABD").<BR>Falls weitere EV3-Bricks über ein Kabel mit dem Haupt-Brick verbunden sind, muss man eine Ziffer entsprechend der Stelle in der Kette hinzufügen (z.B. "3BC", "2A"). In diesem Fall kann man mit einem Befehlr nur die Motoren eines einzelnen Bricks ansprechen.<BR>Geschwindigkeit oder Leistung: Wenn man einen Motor mit einer gewählten Geschwindigkeit betreiben will, dann reguliert der EV3 die Leistung für den Motor permanent so, dass die Geschwindikgkeit eingehalten wird, egal wie viel Widerstand dem entgegenwirkt (zumindest so lange noch genug Leistungsreserve verfügbar ist).</P>
<H3 class="operation">Motor.GetCount (port)</H3>
<P class="operationsummary">Fragt den aktuellen Rotationszähler eines Motors ab.<BR>So lange der Zähler nicht zurückgesetzt wird, misst er alle Bewegungen eines Motors, auch wenn der Motor durch externe Kräfte bewegt wird, während er nicht aktiv läuft.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Name des Motor-Ports</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der aktuelle Wert des Rotationszählers.</P>
<H3 class="operation">Motor.GetSpeed (port)</H3>
<P class="operationsummary">Fragt die derzeitige Geschwindigkeit eines Motors ab.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Motor port name</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Aktuelle Geschwindigkeit im Bereich -100 to 100</P>
<H3 class="operation">Motor.IsBusy (ports)</H3>
<P class="operationsummary">Prüft, ob einer oder mehrere Motoren gerade aktiv laufen.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">"True" wenn zumindest einer der Motoren läuft.</P>
<H3 class="operation">Motor.Move (ports, speed, degrees, brake)</H3>
<P class="operationsummary">Bewegt einen oder mehrere Motoren mit der gewählten Geschindigkeit den angegebenen Winkel weit.<BR>Dieser Befehl blockiert so lange, bis die Bewegung abgeschlossen ist.<BR>Für eine feinere Kontrolle über die Bewegung kann man statt dessen auch Motor.Schedule verwenden.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">speed</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H4 class="parameter">degrees</H4>
<P class="parametersummary">Der Winkel den der Motor drehen soll</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn die Motoren die elektrische Bremse benutzen sollen.</P>
<H3 class="operation">Motor.MovePower (ports, power, degrees, brake)</H3>
<P class="operationsummary">Bewegt einen oder mehrere Motoren mit der gewählten Leistung den angegebenen Winkel weit.<BR>Dieser Befehl blockiert so lange, bis die Bewegung abgeschlossen ist.<BR>Für eine feinere Kontrolle über die Bewegung kann man statt dessen auch Motor.SchedulePower verwenden.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">power</H4>
<P class="parametersummary">Leistung von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H4 class="parameter">degrees</H4>
<P class="parametersummary">Der Winkel den der Motor drehen soll</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn die Motoren die elektrische Bremse benutzen sollen.</P>
<H3 class="operation">Motor.MoveSync (ports, speed1, speed2, degrees, brake)</H3>
<P class="operationsummary">Dreht 2 Motoren synchronisiert einen gewünschten Winkel weit.<BR>Synchronisiert bedeutet, dass die Regelung immer versucht, das Geschwindigkeitsverhältnis beizubehalten, auch wenn ein Motor gebremst wird. In diesem Fall wird der zweite Motor automatisch auch langsamer. Das ist besonders nützlich für Fahrzeuge mit mit unabhängig angetriebenen Rädern, das aber trotzdem gerade oder eine definierte Kurve fahren soll.<BR>Der Winkel für die Gesamtrotation wird immer beim Motor mit der höheren Geschwindigkeit gemessen.<BR>Dieser Befehl blockiert so lange bis die Bewegung abgeschlossen ist.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name der beiden Motor-Ports</P>
<H4 class="parameter">speed1</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem niedrigeren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">speed2</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem höheren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">degrees</H4>
<P class="parametersummary">Der Winkel, den der schnellere Motor zurücklegen soll</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn die Motoren die elektrische Bremse benutzen sollen.</P>
<H3 class="operation">Motor.ResetCount (ports)</H3>
<P class="operationsummary">Setzen den Rotationszähler eines oder mehrerer Motoren auf 0 zurück.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H3 class="operation">Motor.Schedule (ports, speed, degrees1, degrees2, degrees3, brake)</H3>
<P class="operationsummary">Bewegt einen oder mehrere Motoren entsprechend mehrerer Geschwindigkeits-Parameter. Die Geschwindkeit kann positionsabhängig gesteigert oder verringert werden um einen sanften Anlauf oder Stopp zu erreichen.<BR>Der Gesamtwinkel den der Motor drehen soll, ist degrees1+degrees2+degrees3. Am Ende der Bewegung stoppt der Motor automatisch (mit oder ohne Bremsen).<BR>Dieses Kommand kehrt sofort zurück während der Motor noch läuft. Mit IsBusy() kann man testen, wann die Bewegung abgeschlossen ist, oder das Programm kann mit Wait() direkt auf das Ende warten.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">speed</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H4 class="parameter">degrees1</H4>
<P class="parametersummary">Der Teil der Rotation für die Beschleunigung</P>
<H4 class="parameter">degrees2</H4>
<P class="parametersummary">Der Teil der Rotation in gleichmäßiger Bewegung</P>
<H4 class="parameter">degrees3</H4>
<P class="parametersummary">Der Teil der Rotation für das Abbremsen</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn der Motor die elektrische Bremse benutzen soll.</P>
<H3 class="operation">Motor.SchedulePower (ports, power, degrees1, degrees2, degrees3, brake)</H3>
<P class="operationsummary">Bewegt einen oder mehrere Motoren entsprechend mehrerer Leistungs-Parameter. Die Leistung kann positionsabhängig gesteigert oder verringert werden um einen sanften Anlauf oder Stopp zu erreichen.<BR>Der Gesamtwinkel den der Motor drehen soll, ist degrees1+degrees2+degrees3. Am Ende der Bewegung stoppt der Motor automatisch (mit oder ohne Bremsen).<BR>Dieses Kommand kehrt sofort zurück während der Motor noch läuft. Mit IsBusy() kann man testen, wann die Bewegung abgeschlossen ist, oder das Programm kann mit Wait() direkt auf das Ende warten.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">power</H4>
<P class="parametersummary">Leistung von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H4 class="parameter">degrees1</H4>
<P class="parametersummary">Der Teil der Rotation für die Beschleunigung</P>
<H4 class="parameter">degrees2</H4>
<P class="parametersummary">Der Teil der Rotation in gleichmäßiger Bewegung</P>
<H4 class="parameter">degrees3</H4>
<P class="parametersummary">Der Teil der Rotation für das Abbremsen</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn der Motor die elektrische Bremse benutzen soll.</P>
<H3 class="operation">Motor.ScheduleSync (ports, speed1, speed2, degrees, brake)</H3>
<P class="operationsummary">Dreht 2 Motoren synchronisiert einen gewünschten Winkel weit.<BR>Synchronisiert bedeutet, dass die Regelung immer versucht, das Geschwindigkeitsverhältnis beizubehalten, auch wenn ein Motor gebremst wird. In diesem Fall wird der zweite Motor automatisch auch langsamer. Das ist besonders nützlich für Fahrzeuge mit unabhängig angetriebenen Rädern, die aber trotzdem gerade oder eine definierte Kurve fahren sollen.<BR>Der Winkel für die Gesamtrotation wird immer beim Motor mit der höheren Geschwindigkeit gemessen.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name der beiden Motor-Ports</P>
<H4 class="parameter">speed1</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem niedrigeren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">speed2</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem höheren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">degrees</H4>
<P class="parametersummary">Der Winkel, den der schnellere Motor zurücklegen soll</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn die Motoren die elektrische Bremse benutzen sollen.</P>
<H3 class="operation">Motor.Start (ports, speed)</H3>
<P class="operationsummary">Startet einen oder mehrere Motoren mit der gewählten Geschwindigkeit oder setzt die Geschwindigkeit neu fest.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">speed</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H3 class="operation">Motor.StartPower (ports, power)</H3>
<P class="operationsummary">Startet einen oder mehrere Motoren mit der angegebenen Leistung.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">power</H4>
<P class="parametersummary">Leistung von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H3 class="operation">Motor.StartSync (ports, speed1, speed2)</H3>
<P class="operationsummary">Startet zwei Motoren, die synchronisiert mit jeweils einstellbaren Geschwindigkeiten laufen.<BR>Synchronisiert bedeutet, dass die Regelung immer versucht, das Geschwindigkeitsverhältnis beizubehalten, auch wenn ein Motor gebremst wird. In diesem Fall wird der zweite Motor automatisch auch langsamer. Das ist besonders nützlich für Fahrzeuge mit mit unabhängig angetriebenen Rädern, das aber trotzdem gerade oder eine definierte Kurve fahren soll.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name der beiden Motor-Ports</P>
<H4 class="parameter">speed1</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem niedrigeren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">speed2</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem höheren Port-Namen (A vor B, etc.).</P>
<H3 class="operation">Motor.Stop (ports, brake)</H3>
<P class="operationsummary">Stoppt einen oder mehrere Motoren.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn der Motor die elektrische Bremse benutzen soll.</P>
<H3 class="operation">Motor.Wait (ports)</H3>
<P class="operationsummary">Wartet bis ein oder mehrere Motoren ihre Bewegung abgeschlossen habe.			<BR>Dieses Kommando zu benutzen ist normalerweise besser als IsBusy() in einer Schleife abzufragen.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H2 class="object">Program</H2>
<P class="objectsummary">Die Klasse 'Program' enthält Hilfsfunktionen, um die Ausführung von Programmen zu kontrollieren.</P>
<H3 class="property">Program.ArgumentCount - property</H3>
<P class="propertysummary">Ruft die Anzahl der Befehlszeilenargumente ab, die an das Programm übergeben wurden.</P>
<H3 class="property">Program.Directory - property</H3>
<P class="propertysummary">Liefert das Verzeichnis des laufenden Programms.</P>
<H3 class="operation">Program.Delay (milliSeconds)</H3>
<P class="operationsummary">Verzögert die Ausführung eines Programms um die angegebene Anzahl Millisekunden (MilliSeconds).</P>
<H4 class="parameter">milliSeconds</H4>
<P class="parametersummary">Die Verzögerung.</P>
<H3 class="operation">Program.End ()</H3>
<P class="operationsummary">Beendet das Programm.</P>
<H3 class="operation">Program.GetArgument (index)</H3>
<P class="operationsummary">Gibt das Argument zurück, das an das Programm übergeben wurde.</P>
<H4 class="parameter">index</H4>
<P class="parametersummary">Der Index des Arguments.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Das Befehlszeilenargument am angegebenen Index.</P>
<H2 class="object">Sensor</H2>
<P class="objectsummary">Steuert die angeschlossenen Sensoren.<BR>Um einen Sensor-Port zu adressieren, verwendet man die Portnummer, die unterhalb des Ports aufgedruckt ist (z.B. 1). <BR>Um Ports anderer EV3-Bricks, die mit dem Haupt-Brick verbunden sind, anzusprechen, verwendet man die nächst höheren Nummern (5 - 8 für die Sensor-Ports des ersten angeschlossenen Bricks, 9-12 für die des nächsten, und so weiter).</P>
<H3 class="operation">Sensor.CommunicateI2C (port, address, writebytes, readbytes, writedata)</H3>
<P class="operationsummary">Kommuniziert mit Geräten (nicht unbedingt nur Sensoren), die an einem Sensor-Port angeschlossen sind und das I2C-Protokoll verwenden.<BR>Dieser Befehl adressiert ein Gerät am I2C-bus und kann mehrere Bytes senden und empfangen. <BR>Achtung: Dieser Befehl funktioniert nicht bei EV3-Bricks, die an einem Haupt-Brick angeschlossen und von diesem gesteuert werden.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="parameter">address</H4>
<P class="parametersummary">Adresse (0 - 127) des I2C-Slaves am I2C-Bus</P>
<H4 class="parameter">writebytes</H4>
<P class="parametersummary">Anzahl der Bytes, die gesendet werden sollen (maximal 31).</P>
<H4 class="parameter">readbytes</H4>
<P class="parametersummary">Anzahl der Bytes, die empfangen werden sollen (maximal 32, minimal 1).</P>
<H4 class="parameter">writedata</H4>
<P class="parametersummary">Array mit den zu sendenden Bytes (beginnend mit index 0).</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Ein Array mit den empfangenen Bytes. Index beginnt bei 0.</P>
<H3 class="operation">Sensor.GetMode (port)</H3>
<P class="operationsummary">Liest den aktuellen Modus des Sensors.<BR>Viele Sensoren können in sehr verschiedenen Modi arbeiten und sehr unterschiedliche Werte liefern. Zum Beispiel kann der Farbsensor entweder das Umgebungslicht oder reflektiertes Licht, oder die Farbe einer Oberfläche messen. Sobald ein Sensor eingesteckt ist, startet er normalerweise mit Modus 0, kann aber später vom Programm in einen anderen Modus versetzt werden.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Aktuelle Modus (0 ist immer der Anfangs-Modus)</P>
<H3 class="operation">Sensor.GetName (port)</H3>
<P class="operationsummary">Liest den Namen und den Modus eines gerade angeschlossenen Sensors.<BR>Dieser Befehl ist hauptsächlich für Diagnosen nützlich, weil das Programm normalerweise implizit weiß, welche Sensorsen angeschlossen sind.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Lesbarer Text mit Port und Modus(z.B. "TOUCH")</P>
<H3 class="operation">Sensor.GetType (port)</H3>
<P class="operationsummary">Liest die Identificationsnummer des Sensors.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Identificationsnummer (z.B. für einen Tastsensor)</P>
<H3 class="operation">Sensor.IsBusy (port)</H3>
<P class="operationsummary">Prüft, ob ein Sensor gerade mit einem Moduswechsel beschäftigt ist. Nach Umschaltung kann es einige Zeit dauern, bevor neue Messergebnisse vorliegen.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">"True", wenn der Sensor gerade noch beschäftigt ist</P>
<H3 class="operation">Sensor.ReadPercent (port)</H3>
<P class="operationsummary">Liest einen einzelnen Wert und rechnet ihn in eine sinnvolle Prozentangabe um.<BR>Viele Sensoren können ihre gelesenen Werte in einen einzelnen Wert umrechnen, wie z.B. Lichtintenität oder den Zustand eines Tastknopfes.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Prozentwert des gemessenen Werts (z.B.: Ein Tastsensor liefert immer 100 wenn gedrückt, und 0 wenn nicht gedrückt)</P>
<H3 class="operation">Sensor.ReadRaw (port, values)</H3>
<P class="operationsummary">Liest einen Sensorwert wenn das Ergebnis von ReadPercent() nicht ausreichend ist.<BR>Manche Sensoren liefern Werte, die nicht in Prozent ausgedrückt werden können (z.B. ein Farb-Index) oder die aus mehreren Werten auf einmal bestehen (z.B. Entfernung und Richtung des Infrarot-Peilsenders).</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="parameter">values</H4>
<P class="parametersummary">Anzahl der Werte-Komponenten</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Ein Array mit der geforderten Anzahl an Komponenten. Der Index beginnt bei 0. Komponenten, für die der Sensor keinen Wert liefert, werden auf 0 gesetzt.</P>
<H3 class="operation">Sensor.SendUARTData (port, writebytes, writedata)</H3>
<P class="operationsummary">Sendet Daten an Geräte, die über den UART an einen Sensor-Port angeschlossen sind.<BR>Das kann nützlich sein, um verschiedene Spezialkommandos zu einem Sensor/Aktor zu schicken.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="parameter">writebytes</H4>
<P class="parametersummary">Anzahl der zu sendenden Bytes (maximum 32).</P>
<H4 class="parameter">writedata</H4>
<P class="parametersummary">Array mit den Bytes.</P>
<H3 class="operation">Sensor.SetMode (port, mode)</H3>
<P class="operationsummary">Schalten einen Sensor in einen anderen Modus.<BR>Viele Sensoren können in unterschiedlichen Modi arbeiten und sehr verschiedene Messergebnisse liefern. Die Bedeuting der Modus-Nummer hängt vom Sensor-Typ ab. Weitere Information dazu ist im Anhang zu finden.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="parameter">mode</H4>
<P class="parametersummary">Der Modus in den umgeschaltet werden woll. Das funktioniert nur, wenn der Sensor diesen Modus auch unterstützt.</P>
<H3 class="operation">Sensor.Wait (port)</H3>
<P class="operationsummary">Wartet, bis ein Sensor seinen Moduswechsel abgeschlossen hat. Wenn keine Sensor am angegebenen Port angeschlossen ist, kehrt der Befehl sofort zurück.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H2 class="object">Speaker</H2>
<P class="objectsummary">Der eingebaute Lautsprecher des Bricks kann einfache Töne oder Geräuscheffekte abspielen.</P>
<H3 class="operation">Speaker.IsBusy ()</H3>
<P class="operationsummary">Prüft, ob der Lautsprecher noch einen Ton oder einen Geräuscheffekt abspielt.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">"True", wenn noch etwas gespielt wird, sonst "False".</P>
<H3 class="operation">Speaker.Note (volume, note, duration)</H3>
<P class="operationsummary">Beginnt einen Ton zu spielen, der durch eine Text-Beschreibung definiert ist.</P>
<H4 class="parameter">volume</H4>
<P class="parametersummary">Lautstärke im Bereich 0 - 100</P>
<H4 class="parameter">note</H4>
<P class="parametersummary">Text-Beschreibung einer Note "C4"  "B7" oder eines Halbtones wie "C#5"</P>
<H4 class="parameter">duration</H4>
<P class="parametersummary">Dauer des Tones in Millisekunden</P>
<H3 class="operation">Speaker.Play (volume, filename)</H3>
<P class="operationsummary">Spielt einen Geräuscheffekt aus einer am Brick gespeicherten Datei. Derzeit werden nur Dateien im .rsf - Format unterstützt.</P>
<H4 class="parameter">volume</H4>
<P class="parametersummary">Lautstärke im Bereich 0 - 100</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei ohne die .rsf - Erweiterung. Dieser Dateiname kann relativ zum 'prjs'-Verzeichnis oder ein absoluter Pfadname sein (mit führendem '/').</P>
<H3 class="operation">Speaker.Stop ()</H3>
<P class="operationsummary">Stoppt jeden gerade laufenden Ton oder Geräuscheffekt..</P>
<H3 class="operation">Speaker.Tone (volume, frequency, duration)</H3>
<P class="operationsummary">Beginnt einen Ton der angegebenen Frequenz zu spielen.</P>
<H4 class="parameter">volume</H4>
<P class="parametersummary">Lautstärke im Bereich 0 - 100</P>
<H4 class="parameter">frequency</H4>
<P class="parametersummary">Frequenz in Hz im Bereich 250 - 10000</P>
<H4 class="parameter">duration</H4>
<P class="parametersummary">Dauer des Tones in Millisekunden</P>
<H3 class="operation">Speaker.Wait ()</H3>
<P class="operationsummary">Wartet bis der gerade gespielte Ton/Geräuscheffekt fertig ist.</P>
<H2 class="object">Text</H2>
<P class="objectsummary">Das Text-Objekt bietet nützliche Vorgänge für das Arbeiten mit Text.</P>
<H3 class="operation">Text.Append (text1, text2)</H3>
<P class="operationsummary">Fügt zwei Texteingaben zusammen und gibt das Resultat als einen neuen Text zurück. Dieser Vorgang ist besonders dann nützlich, wenn man unbekannten Text in Variablen verarbeitet, der versehentlich als Zahl behandelt und addiert werden könnte, anstelle zusammengefügt zu werden.</P>
<H4 class="parameter">text1</H4>
<P class="parametersummary">Der erste Teil des zu verknüpfenden Textes.</P>
<H4 class="parameter">text2</H4>
<P class="parametersummary">Der zweite Teil des zu verknüpfenden Textes.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der verknüpfte Text mit beiden Bestandteilen.</P>
<H3 class="operation">Text.ConvertToLowerCase (text)</H3>
<P class="operationsummary">Konvertiert den Textteil in kleine Buchstaben.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, der in Kleinbuchstaben umgewandelt werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der angegebene Text in Kleinbuchstaben.</P>
<H3 class="operation">Text.ConvertToUpperCase (text)</H3>
<P class="operationsummary">Konvertiert den Textteil in Großbuchstaben.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, der in Großbuchstaben umgewandelt werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der angegebene Text in Großbuchstaben.</P>
<H3 class="operation">Text.EndsWith (text, subText)</H3>
<P class="operationsummary">Ruft ab, ob ein bestimmter Textabschnitt mit dem angegebenen Textteil endet.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Textabschnitt, in dem gesucht werden soll.</P>
<H4 class="parameter">subText</H4>
<P class="parametersummary">Die gesuchte Zeichenfolge.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">True, wenn die Zeichenfolge am Ende des Textes gefunden wurde.</P>
<H3 class="operation">Text.GetCharacter (characterCode)</H3>
<P class="operationsummary">Je nach Unicode-Zeichencode wird das entsprechende Zeichen abgerufen, das dann als normaler Text verwendet werden kann.</P>
<H4 class="parameter">characterCode</H4>
<P class="parametersummary">Der Unicode-Zeichencode für ein bestimmtes Zeichen.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Das Unicode-Zeichen, das dem Unicode-Zeichencode entspricht.</P>
<H3 class="operation">Text.GetCharacterCode (character)</H3>
<P class="operationsummary">Wird ein Unicode-Zeichen eingegeben, wird der entsprechende Unicode-Zeichencode abgerufen.</P>
<H4 class="parameter">character</H4>
<P class="parametersummary">Das Zeichen, für das der Zeichencode abgerufen werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der Unicode-Zeichencode, der dem angegebenen Zeichen entspricht.</P>
<H3 class="operation">Text.GetIndexOf (text, subText)</H3>
<P class="operationsummary">Sucht die Position einer Zeichenfolge innerhalb eines angegebenen Textes.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, in dem gesucht werden soll.</P>
<H4 class="parameter">subText</H4>
<P class="parametersummary">Der zu suchende Text.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die Position, an der das Textsegment im angegebenen Text erscheint. Wenn der Text nicht erscheint, wird 0 zurückgegeben.</P>
<H3 class="operation">Text.GetLength (text)</H3>
<P class="operationsummary">Ruft die Länge des Textes ab.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, dessen Länge benötigt wird.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die Länge eines angegebenen Textes.</P>
<H3 class="operation">Text.GetSubText (text, start, length)</H3>
<P class="operationsummary">Ruft einen Textteil aus einem größeren Textabschnitt ab.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, dem die Zeichenfolge entnommen werden soll.</P>
<H4 class="parameter">start</H4>
<P class="parametersummary">Bestimmt, wo angefangen werden soll.</P>
<H4 class="parameter">length</H4>
<P class="parametersummary">Bestimmt die Länge einer Zeichenfolge.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Der angeforderte Textteil</P>
<H3 class="operation">Text.GetSubTextToEnd (text, start)</H3>
<P class="operationsummary">Ruft eine Zeichenfolge innerhalb eines Textes ab, angefangen bei einer bestimmten Position bis zum Ende.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, dem die Zeichenfolge entnommen werden soll.</P>
<H4 class="parameter">start</H4>
<P class="parametersummary">Bestimmt, wo angefangen werden soll.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die angeforderte Zeichenfolge.</P>
<H3 class="operation">Text.IsSubText (text, subText)</H3>
<P class="operationsummary">Ruft ab, ob ein Textteil ein Bestandteil eines größeren Textabschnittes ist.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Textabschnitt, in dem die Zeichenfolge gesucht werden soll.</P>
<H4 class="parameter">subText</H4>
<P class="parametersummary">Die gesuchte Zeichenfolge.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">True, wenn die Zeichenfolge im angegebenen Text gefunden wurde.</P>
<H3 class="operation">Text.StartsWith (text, subText)</H3>
<P class="operationsummary">Ruft ab, ob ein bestimmter Textabschnitt mit dem angegebenen Textteil beginnt.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Textabschnitt, in dem gesucht werden soll.</P>
<H4 class="parameter">subText</H4>
<P class="parametersummary">Die gesuchte Zeichenfolge.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">True, wenn die Zeichenfolge zu Beginn des Textes gefunden wurde.</P>
<H2 class="object">Thread</H2>
<P class="objectsummary">Dieses Objekt unterstützt dier Verwendung von Nebenläufigkeiten (Threads) in einem Programm.<BR>Ein Thread ist ein Programmstück, das unabhängig von und gleichzeitig mit anderen Teilen des Programmes ablaufen kann. Zum Beispiel könnte ein Thread die Motoren einer Maschine steuern, während ein anderer Thread Tasteneingaben verarbeitet.<BR>Allgemein gesagt ist Multithreading ein sehr komplexes Thema. Um es wirklich zu verstehen, empfehle ich die Verwendung weiterführender Literatur.</P>
<H3 class="property">Thread.Run - property</H3>
<P class="propertysummary">Mit dieser Objekt-Eigenschaft werden neue Threads erzeugt. Sobald dieser Eigenschaft ein Unterprogram zugewiesen wird, startet dieses Unterprogramm als unabhängiger Thread (zum Beispiel: Thread.Run = MYSUB). <BR>Jedes Unterprogramm kann so als unabhängiger Thread gestartet werden, aber jedes Unterprogramm kann nur einmal zur gleichen Zeit ablaufen. Eine neuerliche Zuweisung zu Thread.Run(), während das Unterprogram noch als Thread läuft, fügt es nur in eine Warteschlange hinzu.<BR>Sobald sich der vorige Thread beendet (Unterprogram läuft zu seinem Ende), wird es automatisch ein weiteres mal gestarted. Es gehen keine Aufrufe verloren, aber sie werden eventuell erst später abgearbeitet als gedacht.<BR>Achtung: Auch wenn noch weitere Threads aktiv sind, wird das ganze Programm terminiert, sobald das Hauptprogramm zu seinem Ende läuft.</P>
<H3 class="operation">Thread.CreateMutex ()</H3>
<P class="operationsummary">Erzeugt einen Mutex (kurz für "Mutual Exclusion" = "gegenseiter Ausschluss") der dann für die Synchronisierung von Threads benutzt werden kann.<BR>Nur die Erzeugung von Mutexes wird unterstützt und kein Löschen. Idealerweise legt ein Programm alle nötigen Mutexe gleich beim Programmstart an speichert die Identifikationsnummern in globalen Variablen.</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Die Identifikationsnummer des neue erzeugten Mutex.</P>
<H3 class="operation">Thread.Lock (mutex)</H3>
<P class="operationsummary">Versucht, den Mutex exklusiv für diesen Thread zu sperren, sodass kein anderer Thread darauf zugreifen kann.<BR>Falls ein anderer Thread bereits den Mutex gesperrt hat, dann wartet dieser Befehl darauf, dass die Sperre aufgehoben wird und sperrt den Mutex dann seinerseits. (Sobald dieser Befehl zurückkehrt, ist garantiert, dass der Mutex erfolgreich durch diesen Thread gesperrt wurde).<BR>Dieser Sperr-Mechanismus wird normalerweise benutzt, um den Zugriff auf gemeinsame Datenstrukturen oder Resourcen zu koordinieren. <BR>Jeder Aufruf von Lock() muss mit einem nachfolgenden Aufruf von Unlock() aufgelöst werden.</P>
<H4 class="parameter">mutex</H4>
<P class="parametersummary">Die Identifikationsnummer des Mutex (wie von CreateMutex() zurückgeliefert)</P>
<H3 class="operation">Thread.Unlock (mutex)</H3>
<P class="operationsummary">Gibt einen Mutex wieder frei. Dieser Befehl darf nur nach einem vorangegangen Lock() benutzt werden.</P>
<H4 class="parameter">mutex</H4>
<P class="parametersummary">Die Identifikationsnummer des Mutex</P>
<H3 class="operation">Thread.Yield ()</H3>
<P class="operationsummary">Gibt die Kontrolle über die CPU explizit an dieser Stelle frei.<BR>Threads laufen oft nicht wirklich parallel, weil es nicht genug CPUs für alle Threads gibt. Statt dessen macht eine CPU ein wenig Arbeit für einen Thread und schaltet dann schnell zu einem anderen Thread weiter. Dadurch entsteht der Eindruck, dass alles parallel abläuft.<BR>Falls ein Thread gerade nichts zu tun hat, weil er gerade darauf wartet, dass irgendeine Bedingung eintritt, kann er die Kontrolle mit Yield() vorzeitig an andere Threads abgeben, die dann die Chance haben, ihre Arbeit durchzuführen.</P>
<H2 class="object">Vector</H2>
<P class="objectsummary">Dieses Objekt bietet verschiedene Operationen zur Manipulation größerer Zahlenmengen.<BR>Sie werden Vektoren genannt und werden in normalen Arrays mit fortlaufendem Index, beginnend bei 0, abgelegt.<BR>Wenn Operationen mit Arrays mit einer abweichenden Struktur aufgerufen werden, wird jedes fehlende Array-Element als 0 angenommen.</P>
<H3 class="operation">Vector.Add (size, A, B)</H3>
<P class="operationsummary">Addiert zwei Vektoren elementweise (C[0]=A[0]+B[0], C[1]=A[1]+B[2]...)</P>
<H4 class="parameter">size</H4>
<P class="parametersummary">Anzahl der Elemente von jedem Vektor für die Berechnung</P>
<H4 class="parameter">A</H4>
<P class="parametersummary">Erster Vektor</P>
<H4 class="parameter">B</H4>
<P class="parametersummary">Zweiter Vektor</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">A Vektor der angegebenen Größe, der alle Summen enhält.</P>
<H3 class="operation">Vector.Init (size, value)</H3>
<P class="operationsummary">Initialisiert einen Vektor mit angegebener Länge und Startwert für alle Elemente.</P>
<H4 class="parameter">size</H4>
<P class="parametersummary">Länge des Vektors</P>
<H4 class="parameter">value</H4>
<P class="parametersummary">Der Wert für alle Elemente</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Den neu erzeugten Vektor</P>
<H3 class="operation">Vector.Multiply (rows, columns, k, A, B)</H3>
<P class="operationsummary">Matrizenmultiplikation.<BR>Die Eingabevektoren werden jeweils als zweidimensioinale Matrix von gegebener Höhe und Breite interpretiert. Die einzelnen Zeilen der Matrix sind in den Vektor direkt nacheinander abgelegt.<BR>Mehr zur Definition von Matrizenmultiplikation gibt es auf: https://de.wikipedia.org/wiki/Matrizenmultiplikation .</P>
<H4 class="parameter">rows</H4>
<P class="parametersummary">Anzahl der Zeilen der Ergebnis-Matrix</P>
<H4 class="parameter">columns</H4>
<P class="parametersummary">Anzahl der Spalten der Ergebnis-Matrix</P>
<H4 class="parameter">k</H4>
<P class="parametersummary">Anzahl der Spalten in Matrix A und gleichzeitig der Zeilen in Matrix B</P>
<H4 class="parameter">A</H4>
<P class="parametersummary">Ein Matrix der Größe rows * k</P>
<H4 class="parameter">B</H4>
<P class="parametersummary">Eine Matrix der Größe k * columns</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Eine neue Matrix mit dem Multiplikationsergebnis</P>
<H3 class="operation">Vector.Sort (size, A)</H3>
<P class="operationsummary">Sortiert die Element eines Vektors in aufsteigender Reihenfolge.</P>
<H4 class="parameter">size</H4>
<P class="parametersummary">Anzahl der Elements</P>
<H4 class="parameter">A</H4>
<P class="parametersummary">Der zu sortierende Vektor</P>
<H4 class="returns">Returns</H4>
<P class="returnssummary">Ein neuer Vektor mit den sortierten Elementen</P>

<H1 class="chapter">Appendix - Sensors</H1>

<PRE>
Type  Mode  Name            get reading with   delivers 

1        0  NXT-TOUCH       ReadPercent        0=not pressed,  100=pressed  

4        0  NXT-COL-REF     ReadPercent        0=no reflective light, 100=maximum reflective light
4        1  NXT-COL-AMB     ReadPercent        0=no ambient light, 100=maximum ambient light
4        2  NXT-COL-COL     ReadRaw (1 value)  1=black, 2=blue, 3=green, 4=yellow, 5=red, 6=white

5        0  NXT-US-CM       ReadRaw (1 value)  distance in cm

16       0  TOUCH           ReadPercent        0=not pressed,  100=pressed  

29       0  COL-REFLECT     ReadPercent        0=no reflective light, 100=maximum reflective light
29       1  COL-AMBIENT     ReadPercent        0=no ambient light, 100=maximum ambient light
29       2  COL-COLOR       ReadRaw (1 value)  0=unknown, 1=black, 2=blue, 3=green, 4=yellow, 5=red, 6=white, 7=brown
29       5  RGB-RAW         ReadRaw (3 values) value1=red intensity, value2=green intensity, value3=blue intensity

33       0  IR-PROX         ReadPercent        distance in cm (not very accurate)
33       1  IR-SEEK         ReadRaw (2 values) direction and distance to IR beacon
33       2  IR-REMOTE       ReadRaw (4 values) value1=signal from channel 1 (*), value2=signal from channel 2...
                                    a remote control sender can be switched to use one of 4 channels 
                                    (slider on top position is channel 1) and the remote receiver can detect 
                                    all channel signals at the same time
                                               											       
(*) numbers for the remote control buttons (A=left top, B=left bottom, C=right top, D=right bottom, E=beacon activated):
	A = 1    A&B = 10   B&C = 7
	B = 2    A&C = 5    B&D = 8
	C = 3    A&D = 6    C&D = 11
	D = 4               E = 9
   other combinations give a reading of 0
</PRE>   

</BODY>
</HTML>
