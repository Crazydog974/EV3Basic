// global data for various functions

DATAS INDIRECTMEMORY 252
DATA32 STOPLCDUPDATE
DATA32 RAWVALUE0
DATA32 RAWVALUE1
DATA32 RAWVALUE2
DATA32 RAWVALUE3
DATA32 RAWVALUE4
DATA32 RAWVALUE5
DATA32 RAWVALUE6
DATA32 RAWVALUE7


// ------------------------------------------ LANGUAGE FEATURES ----------------------------
subcall DIV            // FFF
{
	IN_F a
	IN_F b
	OUT_F result
	
	JR_EQF C0 b divisionbyzero	
	DIVF a b result
	RETURN
divisionbyzero:	
	MOVE32_f 0 result
	RETURN
}

subcall EQ_STRING       // SSS
{
	IN_S  a 252
	IN_S  b 252
	OUT_S result 8
	
	DATA8 flag
	
	// check if completely equal
	STRINGS COMPARE a b flag
	JR_NEQ8 FLAG 0 isequal
	// second chance: when both values are "True" in any casing, this also counts as equal
	AND8888_32 a -538976289 a        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE a 'TRUE' flag	
	JR_EQ8 0,flag,isnotequal
	AND8888_32 b -538976289 b        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE b 'TRUE' flag	
	JR_EQ8 0,flag,isnotequal
isequal:
	STRINGS DUPLICATE 'True' result
	RETURN
isnotequal:
	STRINGS DUPLICATE 'False' result
	RETURN
}

subcall NE_STRING       // SSS
{
	IN_S  a 252
	IN_S  b 252
	OUT_S result 8
	
	DATA8 flag
	
	// check if completely equal
	STRINGS COMPARE a b flag
	JR_NEQ8 flag 0 isequal
	// second chance: when both values are "True" in any casing, this also counts as equal
	AND8888_32 a -538976289 a        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE a 'TRUE' flag	
	JR_EQ8 0 flag isnotequal
	AND8888_32 b -538976289 b        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE b 'TRUE' flag	
	JR_EQ8 0 flag isnotequal
isequal:
	STRINGS DUPLICATE 'False' result
	RETURN
isnotequal:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall EQ_FLOAT       // FFS
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_EQF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall NE_FLOAT        // FFS
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_NEQF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall LT        // FFS
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_LTF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall GT         // FFS   
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_GTF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall LE        // FFS    
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_LTEQF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall GE        // FFS    
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_GTEQF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall LE_STEP    // FFFS    
// WHEN step>=0  :  result  <- "True" iff a <= b
// ELSE          :  result  <- "True" iff a >= b
{
	IN_F a
	IN_F b
	IN_F step
	OUT_S result 8
	
	JR_LTF step,C0,negativestep	
	JR_GTF a b deliverfalse
delivertrue:	
	STRINGS DUPLICATE 'True' result	
	RETURN	
negativestep:
	JR_LTEQF b a delivertrue
deliverfalse:
	STRINGS DUPLICATE 'False' result
	RETURN
}

subcall AND		      // SSS
{
	IN_S a 8
	IN_S b 8
	OUT_S result 8
	
	AND8888_32 a -538976289 a        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE a 'TRUE' a	
	JR_EQ8 a 0 deliverfalse	
	AND8888_32 b -538976289 b        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE b 'TRUE' b	
	JR_EQ8 b 0 deliverfalse	
delivertrue:
	STRINGS DUPLICATE 'True' result
	RETURN
deliverfalse:
	STRINGS DUPLICATE 'False' result
}

subcall OR		     // SSS  
{
	IN_S a 8
	IN_S b 8
	OUT_S result 8

	AND8888_32 a -538976289 a        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE a 'TRUE' a	
	JR_NEQ8 a 0 delivertrue	
	AND8888_32 b -538976289 b        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE b 'TRUE' b	
	JR_EQ8 b 0 deliverfalse	
delivertrue:
	STRINGS DUPLICATE 'True' result
	RETURN
deliverfalse:
	STRINGS DUPLICATE 'False' result
}

subcall ARRAYCREATE_FLOAT   // F
{
	OUT_32 handle
	
	DATA16 h16
	ARRAY CREATEF 8 h16			// create with 8 elements
	ARRAY FILL h16 C0
	
	MOVE16_32 h16 handle
}

subcall ARRAYSTORE_FLOAT   // FFFV
{
	IN_32 handle
	IN_F index
	IN_F value	
	
	DATA16 h16
	DATA32 index32
	DATA32 len	
	MOVE32_16 handle h16
	MOVEF_32 index index32

	ARRAY SIZE h16 len
	JR_LT32 index32 0 negativeindex
	JR_LT32 index32 len arraybigenough

increasesize:	
	DATA32 doublelen
	ADD32 len len doublelen
	ARRAY RESIZE h16 doublelen
writeloop:	
	ARRAY_WRITE h16 len C0
	ADD32 len 1 len
	JR_LT32 len doublelen writeloop
	JR_GTEQ32 index32 len increasesize
	
arraybigenough:
	ARRAY_WRITE h16 index32 value
negativeindex:
}

subcall ARRAYGET_FLOAT     // FFF
{
	IN_32 handle
	IN_F index
	OUT_F value
	
	DATA16 h16
	DATA32 index32
	DATA32 len
	MOVE32_16 handle h16
	MOVEF_32 index index32
	
	ARRAY SIZE h16 len
	JR_LT32 index32 0 outofbounds
	JR_GTEQ32 index32 len outofbounds
	
	ARRAY_READ h16 index32 value
	RETURN
outofbounds:
	MOVE8_F 0 value	
}

subcall ARRAYCREATE_STRING   // F
{
	OUT_32 handle

	DATA16 h16
	DATA8 z
	
	ARRAY CREATEF 504  h16     // 504 bytes are enough to store 2 strings
	MOVE8_8 0 z
	ARRAY FILL h16 z

	MOVE16_32 h16 handle
}

subcall ARRAYSTORE_STRING   // FFSV
{
	IN_32 handle
	IN_F index
	IN_S value 252	
	
	DATA16 h16
	DATA32 index32
	DATA32 len	
	MOVE32_16 handle h16
	MOVEF_32 index index32
	MUL32 index32 252 index32
	
	ARRAY SIZE h16 len
	JR_LT32 index32 0 negativeindex
	JR_LT32 index32 len arraybigenough

increasesize:	
	DATA32 doublelen
	ADD32 len len doublelen
	ARRAY RESIZE h16 doublelen
	DATA8 zerobyte	
	MOVE8_8 0 zerobyte
writeloop:	
	ARRAY_WRITE h16 len zerobyte      // only write a 0 at begin of each string (rest does not matter)
	ADD32 len 252 len
	JR_LT32 len doublelen writeloop
	JR_GTEQ32 index32 len increasesize
	
arraybigenough:
	ARRAY WRITE_CONTENT 1 h16 index32 252 value
negativeindex:
}
	
subcall ARRAYGET_STRING   // FFS
{
	IN_32 handle
	IN_F index
	OUT_S value 252	

	DATA16 h16
	DATA32 index32
	MOVE32_16 handle h16
	MOVEF_32 index index32
	
	MUL32 252 index32 index32 // every string has 252 bytes
	MOVE8_8 0 value		  // set to empty string in case that nothing can be read
	
	ARRAY READ_CONTENT 1 h16 index32 252 value   // tansfer memory from program slot 1
}


// ------------------------------------------ BASIC MODULE: PROGRAM -------------------------------------------------

subcall PROGRAM.DELAY    // FV
{
	IN_F milliseconds
	
	DATA32 milliseconds_32
	MOVEF_32 milliseconds milliseconds_32

	DATA32 timer
	TIMER_WAIT(milliseconds_32,timer)
	TIMER_READY(timer)	
}

subcall PROGRAM.END   // V
{
	PROGRAM_STOP -1
}

// ------------------------------------------ BASIC MODULE: TEXT ---------------------------------------------------

subcall TEXT.APPEND     // SSS
{
	IN_S a 252
	IN_S b 252
    OUT_S result 252
	
	DATA16 len0
	DATA16 len1
	DATA16 sum

	STRINGS GET_SIZE a len0
	STRINGS GET_SIZE b len1
	ADD16 len0,len1,sum
	JR_GT16 sum,251,stringsizeexceeded

	STRINGS ADD a b result
	RETURN
	
stringsizeexceeded:	
    STRINGS DUPLICATE a result
}

subcall TEXT.CONVERTTOLOWERCASE  // SS
{
	IN_S a 252
	OUT_S result 252
	
	STRINGS DUPLICATE a INDIRECTMEMORY
	DATA16 len 
	STRINGS GET_SIZE a len

	DATA32 i
	MOVE16_32 len i
loop:
	SUB32 i 1 i
	JR_LT32 i 0 endloop
	
	DATA8 c
	MEMORY_READ 1 0 i 1 c	
	JR_LT8 c 0 extendedrange    // unicode >= 128 (because c is negative)
	JR_LT8 c 65 loop            // unicode < 65  (no conversion necessary)
	JR_GT8 c 90 loop            // unicode > 90  (no conversion necessary)
	ADD8 c 32 c                 // convert 'A'..'Z' -> 'a'..'z'
	MEMORY_WRITE 1 0 i 1 c	
	JR loop	
extendedrange:     
	JR_LT8 c -64 loop           // unicode < 192  (no conversion necessary)
	JR_GT8 c -34 loop           // unicode > 222  (no conversion necessary)
	JR_EQ8 c -41 loop           // unicode = 215  (no conversion necessary)             
	ADD8 c 32 c                 // convert to lowercase
	MEMORY_WRITE 1 0 i 1 c	
	JR loop								
endloop:	
	STRINGS DUPLICATE INDIRECTMEMORY result
}

subcall TEXT.CONVERTTOUPPERCASE  // SS
{
	IN_S a 252
	OUT_S result 252
	
	STRINGS DUPLICATE a INDIRECTMEMORY
	DATA16 len 
	STRINGS GET_SIZE a len

	DATA32 i
	MOVE16_32 len i
loop:
	SUB32 i 1 i
	JR_LT32 i 0 endloop
	
	DATA8 c
	MEMORY_READ 1 0 i 1 c	
	JR_LT8 c 0 extendedrange    // unicode >= 128 (because c is negative)
	JR_LT8 c 97 loop            // unicode < 97  (no conversion necessary)
	JR_GT8 c 122 loop           // unicode > 122  (no conversion necessary)
	SUB8 c 32 c                 // convert 'a'..'z' -> 'A'..'Z'
	MEMORY_WRITE 1 0 i 1 c	
	JR loop	
extendedrange:     
	JR_LT8 c -32 loop           // unicode < 224  (no conversion necessary)
	JR_GT8 c -2 loop            // unicode > 254  (no conversion necessary)
	JR_EQ8 c -9 loop            // unicode = 247  (no conversion necessary)             
	SUB8 c 32 c                 // convert to lowercase
	MEMORY_WRITE 1 0 i 1 c	
	JR loop								
endloop:	
	STRINGS DUPLICATE INDIRECTMEMORY result
}

subcall TEXT.ENDSWITH    // SSS
{
	IN_S a 252
	IN_S b 252
	OUT_S result 8
	
	DATA16 len0
	DATA16 len1
	DATA8 flag
	
	STRINGS GET_SIZE a len0
	STRINGS GET_SIZE b len1
	JR_LT16 len0 len1 deliverfalse     // second string is longer
	JR_EQ16 len1 0 deliverfalse        // second string is empty
	JR_GT16 len0 len1 hasoversize	

	STRINGS COMPARE a b flag           // have same size	
	JR_EQ8 0 flag deliverfalse
	STRINGS DUPLICATE 'True' result
	RETURN
	
hasoversize:	
	DATA16 oversize
	SUB16 len0 len1 oversize
	DATA32 offset
	MOVE16_32 oversize offset
	DATA32 size
	MOVE16_32 len1 size
	ADD32 size 1 size
	STRINGS DUPLICATE a INDIRECTMEMORY
	// THIS IS THE ONLY METHOD AVAILABLE FOR INDIRECT ADDRESSING	
	// (assumes that the current program runs in slot 1)	
	MEMORY_READ 1 0 offset size INDIRECTMEMORY
	
	STRINGS COMPARE INDIRECTMEMORY b flag
	JR_EQ8 0 flag deliverfalse
	STRINGS DUPLICATE 'True' result
	RETURN
	
deliverfalse:
	STRINGS DUPLICATE 'False' result
}

subcall TEXT.GETINDEXOF   // SSF
{
	IN_S a  252
	IN_S b  252
	OUT_F result

	DATA16 la
	DATA16 lb
	DATA16 diff
	DATA8 flag
	
	STRINGS GET_SIZE a la
	STRINGS GET_SIZE b lb
	JR_LTEQ16 lb 0 notfound   // empty search string
	JR_GT16 lb la notfound  // search string is bigger than a
	SUB16 la lb diff        // size difference
	
	DATAS c 252
	STRINGS DUPLICATE b c    // prepare temporary string to have correct size
	STRINGS DUPLICATE a INDIRECTMEMORY  // put a into addressable memory

	DATA32 index
	DATA32 endindex
	DATA32 size
	MOVE16_32 0 index
	MOVE16_32 diff endindex
	MOVE16_32 lb size
loop:	
	MEMORY_READ 1 0 index size c
	STRINGS COMPARE b c flag
	JR_EQ8 flag 0 nothere
	
	ADD32 index 1 index   // basic index is starts with 1
	MOVE32_F index result
	RETURN
	
nothere:	
	ADD32 index,1,index
	JR_LTEQ32 index endindex loop
	
notfound:
	MOVE8_F 0 result
}

subcall TEXT.ISSUBTEXT   // SSS
{
	IN_S a  252
	IN_S b  252
	OUT_S result 8

	DATA16 la
	DATA16 lb
	DATA16 diff
	DATA8 flag
	
	STRINGS GET_SIZE a la
	STRINGS GET_SIZE b lb
	JR_LTEQ16 lb 0 notfound   // empty search string
	JR_GT16 lb la notfound  // search string is bigger than a
	SUB16 la lb diff        // size difference
	
	DATAS c 252
	STRINGS DUPLICATE b c    // prepare temporary string to have correct size
	STRINGS DUPLICATE a INDIRECTMEMORY  // put a into addressable memory

	DATA32 index
	DATA32 endindex
	DATA32 size
	MOVE16_32 0 index
	MOVE16_32 diff endindex
	MOVE16_32 lb size
loop:	
	MEMORY_READ 1 0 index size c
	STRINGS COMPARE b c flag
	JR_EQ8 flag 0 nothere
	
	STRINGS DUPLICATE 'True' result
	RETURN
	
nothere:	
	ADD32 index,1,index
	JR_LTEQ32 index endindex loop
	
notfound:	
	STRINGS DUPLICATE 'False' result
}


subcall TEXT.STARTSWITH    // SSS
{
	IN_S a 252
	IN_S b 252
	OUT_S result 8

	DATA16 len0
	DATA16 len1
	DATA8 flag
	
	STRINGS GET_SIZE a len0
	STRINGS GET_SIZE b len1
	JR_LT16 len0 len1 deliverfalse     // second string is longer
	JR_EQ16 len1 0 deliverfalse        // second string is empty
	JR_GT16 len0 len1 hasoversize	   

	STRINGS COMPARE a b flag           // have same size	
	JR_EQ8 0 flag deliverfalse
	STRINGS DUPLICATE 'True' result
	RETURN
	
hasoversize:
    DATA32 size
	MOVE16_32 len1 size
	MEMORY_WRITE 1 0 0 size a
	MEMORY_WRITE 1 0 size 1 ''
	STRINGS COMPARE INDIRECTMEMORY b flag
	JR_EQ8 0 flag deliverfalse
	STRINGS DUPLICATE 'True' result
    RETURN
	
deliverfalse:
	STRINGS DUPLICATE 'False' result
}

subcall TEXT.GETCHARACTER   // FS
{
	IN_F c_f
	OUT_S result 2
	
	DATA32 c	
	MOVEF_32 c_f c
		
   	STRINGS DUPLICATE ' ' result

	JR_LT32 c,1,unsupported
	JR_GT32 c,255,unsupported	
	
	MOVE32_8 c result
	RETURN
  unsupported:
	MOVE8_8 1 result
}

subcall TEXT.GETCHARACTERCODE   // SF
{
	IN_S a 4
	OUT_F result

	DATA16 c
	MOVE8_16 a c
	AND16 c 255 c
	
	MOVE16_F c result
}

subcall TEXT.GETSUBTEXT      // SFFS
{
	IN_S a 252
	IN_F start_f
	IN_F sublength_f
	OUT_S result 252

	// convert float parameters to integer values
	DATA16 start
	DATA16 sublength	
	MOVEF_16 start_f start	   // rounding towards 0
	SUB16 start 1 start        // use index 0 for start instead of index 1		
	MOVEF_16 sublength_f sublength  // rounding towards 0
	// special handling: a sublength >0.0 and <=1.0 must be treated as 1 (strange behaviour of SmallBasic)
	JR_NEQ16 sublength 0 nospeciallength
	JR_LTEQF sublength_f C0 nospeciallength
	MOVE16_16 1 sublength
nospeciallength:
	
	// determine which part of the string needs to be taken (if any)
	DATA16 len              // length of original string
	STRINGS GET_SIZE a len
	
	JR_LT16 start 0 nothingremains
	JR_LTEQ16 sublength 0 nothingremains
	DATA16 lenafterstart
	SUB16 len start lenafterstart
	JR_LTEQ16 lenafterstart 0 nothingremains

	JR_LTEQ16 sublength lenafterstart getfullsublength
	MOVE16_16 lenafterstart sublength      // reduce sublength to available data
getfullsublength:	

	STRINGS DUPLICATE a INDIRECTMEMORY
	DATA32 offset
	DATA32 size
	DATA32 end

	MOVE16_32 start offset
	MOVE16_32 sublength size
	ADD32 offset size end

	MEMORY_WRITE 1 0 end 1 ''    // insert string end marker
	ADD32 size 1 size            // also copy the end marker
	MEMORY_READ 1 0 offset size result	
	RETURN
	
nothingremains:
	STRINGS DUPLICATE '', result
}

subcall TEXT.GETSUBTEXTTOEND     // SFS
{
	IN_S a 252
	IN_F start_f 
	OUT_S result 252
	
	DATA16 start
	MOVEF_16 start_f start	
	SUB16 start 1 start   // use index 0 for start instead of index 1
	DATA16 len
	STRINGS GET_SIZE a len
	
	JR_LT16 start 0 nothingremains
	JR_GTEQ16 start len nothingremains
	
	STRINGS DUPLICATE a INDIRECTMEMORY
	DATA32 offset	
	MOVE16_32 start offset
	DATA32 size
	MOVE16_32 len size
	SUB32 size offset size
	ADD32 size 1 size
	MEMORY_READ 1 0 offset size result
	RETURN
	
nothingremains:
	STRINGS DUPLICATE '', result
}

subcall TEXT.GETLENGTH      // SF
{
	IN_S a 252
	OUT_F result
	
	DATA16 tmp
	STRINGS GET_SIZE a tmp
	MOVE16_F tmp result
}

// ---------------------------------------- BASIC MODULE: MATH ---------------------------------------

subcall MATH_PI              // F
{
	OUT_F result
	STRINGS STRING_TO_VALUE '3.1415926535897932384' result
}

subcall MATH.ABS             // FF
{
	IN_F a
	OUT_F result

	MATH ABS a result
}
subcall MATH.ARCCOS          // FF
{
	IN_F a
	OUT_F result

	MATH ACOS a result
	DIVF result CR2D result
}
subcall MATH.ARCSIN          // FF
{
	IN_F a
	OUT_F result

	MATH ASIN a result
	DIVF result CR2D result
}
subcall MATH.ARCTAN          // FF
{
	IN_F a
	OUT_F result

	MATH ATAN a result
	DIVF result CR2D result
}
subcall MATH.CEILING          // FF
{
	IN_F a
	OUT_F result

	MATH CEIL a result
	JR_EQF C0 result preventnegativezero	
	RETURN
preventnegativezero:	
	MOVE32_F 0 result
}
subcall MATH.COS              // FF
{
	IN_F a
	OUT_F result

	MULF a CR2D a
	MATH COS a result
}
subcall MATH.FLOOR          // FF
{
	IN_F a
	OUT_F result

	MATH FLOOR a result
}
subcall MATH.GETDEGREES       // FF
{
	IN_F a
	OUT_F result
	
	MULF a CR2D result
}
subcall MATH.GETRADIANS       // FF
{
	IN_F a
	OUT_F result

	DIVF a CR2D result
}
subcall MATH.GETRANDOMNUMBER   // FF
{
	IN_F range
	OUT_F result
	
	DATA16 range_16
	DATA16 value
	MOVEF_16 range range_16
	
	RANDOM 1 range_16 value
	MOVE16_F value result
}
subcall MATH.LOG               // FF
{
	IN_F a
	OUT_F result
	
	MATH LOG a result
}
subcall MATH.MAX              // FFF
{
	IN_F a
	IN_F b
	OUT_F result
	
	JR_GTF b a biggerb
    MOVEF_F a result	
	RETURN
biggerb:
	MOVEF_F b result
}
subcall MATH.MIN              // FFF
{
	IN_F a
	IN_F b
	OUT_F result
	
	JR_GTF b a biggerb
    MOVEF_F b result	
	RETURN
biggerb:
	MOVEF_F a result
}
subcall MATH.NATURALLOG       // FF
{
	IN_F a
	OUT_F result
	
	MATH LN a result
}
subcall MATH.POWER            // FFF
{
	IN_F base
	IN_F exponent
	OUT_F result
	
	MATH POW base exponent result
}
subcall MATH.REMAINDER        // FFF
{
	IN_F dividend
	IN_F divisor
	OUT_F result
	
	MATH MOD dividend divisor result
}
subcall MATH.ROUND           // FF
{
	IN_F a
	OUT_F result
	
	MATH ROUND a result
}
subcall MATH.SIN            // FF
{
	IN_F a
	OUT_F result	
	
	MULF a CR2D a
	MATH SIN a result
}
subcall MATH.SQUAREROOT      // FF
{
	IN_F a
	OUT_F result
	
	MATH SQRT a result
}
subcall MATH.TAN            // FF
{
	IN_F a
	OUT_F result
	
	MULF a CR2D a
	MATH TAN a result
}

// -------------------------------------- EXTENSION MODULE: ASSERT -----------------------------------

subcall ASSERT.FAILED     // SV  
{
	IN_S message 252
	DATA32 timer
	
	UI_DRAW CLEAN
	UI_DRAW SELECT_FONT 1
	UI_DRAW TEXT 1 0 16 'ASSERT FAILED'

	DATA8 zerobyte
	MOVE8_8 0 zerobyte
	DATA16 y
	MOVE16_16 32 y
	
linesloop:
	DATA16 len	
	STRINGS GET_SIZE message len
	JR_LTEQ16 len 20 lastline
	
	STRINGS DUPLICATE message INDIRECTMEMORY
	MEMORY_WRITE 1 0 20 1 zerobyte
	UI_DRAW TEXT 1 0 y INDIRECTMEMORY
	
	ADD16 y,16,y	
	STRINGS DUPLICATE message INDIRECTMEMORY
	MEMORY_READ 1 0 20 232 message
		
	JR linesloop
	
lastline:
	UI_DRAW TEXT 1 0 y message
	UI_DRAW UPDATE	
	
	TIMER_WAIT(10000,timer)
	TIMER_READY(timer)	
}

subcall ASSERT.EQUAL      // SSSV   ASSERT.FAILED TEXT.APPEND
{
	IN_S a 252
	IN_S b 252
	IN_S message 252
	
	DATA8 flag
	
	STRINGS COMPARE a b flag
	JR_NEQ8 flag 0 isok
	
	CALL TEXT.APPEND message, ' (', message
	CALL TEXT.APPEND message, a, message
	CALL TEXT.APPEND message, '<>', message
	CALL TEXT.APPEND message, b, message
	CALL TEXT.APPEND message, ')', message
	
	CALL ASSERT.FAILED message	
isok:
}

subcall ASSERT.NOTEQUAL      // SSSV     ASSERT.FAILED
{
	IN_S a 252
	IN_S b 252
	IN_S message 252
	
	DATA8 flag
	
	STRINGS COMPARE a b flag
	JR_EQ8 flag 0 isok
	CALL ASSERT.FAILED message	
isok:
}

subcall ASSERT.GREATER      // FFSV     ASSERT.FAILED
{
	IN_F a
	IN_F b
	IN_S message 252
	
	JR_GTF a b isok
	CALL ASSERT.FAILED message	
isok:
}

subcall ASSERT.GREATEREQUAL   // FFSV     ASSERT.FAILED
{
	IN_F a
	IN_F b
	IN_S message 252
	
	JR_GTEQF a b isok
	CALL ASSERT.FAILED message	
isok:
}

subcall ASSERT.LESS   // FFSV      ASSERT.FAILED
{
	IN_F a
	IN_F b
	IN_S message 252
	
	JR_LTF a b isok
	CALL ASSERT.FAILED message	
isok:
}

subcall ASSERT.LESSEQUAL   // FFSV    ASSERT.FAILED
{
	IN_F a
	IN_F b
	IN_S message 252
	
	JR_LTEQF a b isok
	CALL ASSERT.FAILED message	
isok:
}

subcall ASSERT.NEAR   // FFSV    ASSERT.FAILED
{
	IN_F a
	IN_F b
	IN_S message 252
	
	DATAF tmp
	DATAF epsilon
	MOVE32_F 1 epsilon
	MOVE32_F 5000000 tmp
	DIVF epsilon tmp epsilon

	SUBF b epsilon tmp
	JR_LTF a tmp failed
	ADDF b epsilon tmp
	JR_GTF a tmp failed
		
	RETURN
	
failed:	
	CALL ASSERT.FAILED message	
}

// ------------------------------------------ EV3 MODULE: EV3 -------------------------------------------------

subcall EV3.SETLEDCOLOR    // SSV
{
	IN_S color 8		// only receive first 7 characters
	IN_S effect 8       // only receive first 7 characters
	
	ARRAY8 color_1 4	// split up to be able to do some operations with 4 bytes each
	ARRAY8 color_2 4
	ARRAY8 effect_1 4
	ARRAY8 effect_2 4

	STRINGS DUPLICATE color color_1
	STRINGS DUPLICATE effect effect_1	
	AND8888_32 color_1 -538976289 color_1        // AND 0xdfdfdfdf performs an upcase for 4 letters
	AND8888_32 color_2 -538976289 color_2        // AND 0xdfdfdfdf performs an upcase for 4 letters
	AND8888_32 effect_1 -538976289 effect_1      // AND 0xdfdfdfdf performs an upcase for 4 letters	
	AND8888_32 effect_2 -538976289 effect_2      // AND 0xdfdfdfdf performs an upcase for 4 letters	
	
	DATA8 col
	DATA8 flag
	MOVE8_8 0 col
	
	STRINGS COMPARE color_1 'GREEN' flag
	JR_EQ8 flag 0 notgreen
	MOVE8_8 1 col
	JR checkeffect
notgreen:	
	STRINGS COMPARE color_1 'RED' flag
	JR_EQ8 flag 0 notred
	MOVE8_8 2 col
	JR checkeffect
notred:	
	STRINGS COMPARE color_1 'ORANGE' flag
	JR_EQ8 flag 0 setcol
	MOVE8_8 3 col
checkeffect:
	
	STRINGS COMPARE effect_1 'FLASH' flag
	JR_EQ8 flag 0 noflash
	ADD8 col 3 col
	JR setcol
noflash:
	STRINGS COMPARE effect_1 'PULSE' flag
	JR_EQ8 flag 0 setcol
	ADD8 col 6 col	
	
setcol:
	UI_WRITE LED col
}

subcall EV3.TIME  // F
{
	OUT_F time
	
	DATA32 ms
	DATAF thousand
	
	TIMER_READ ms
	MOVE32_F ms time	
}

// ------------------------------------------ EV3 MODULE: LCD -------------------------------------------------

subcall LCD.MEMORIZECHANGES    // V
{
	MOVE32_32 1 STOPLCDUPDATE
}

subcall LCD.UPDATE  // V
{
	MOVE32_32 0 STOPLCDUPDATE
	UI_DRAW(UPDATE)
}

subcall LCD.CLEAR   // V
{
	UI_DRAW(TOPLINE,0)
	UI_DRAW(CLEAN)
	
	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW(UPDATE)
skipupdate:
}

subcall LCD.RECT      // FFFFFV
{
	IN_F col
	IN_F x
	IN_F y
	IN_F w
	IN_F h	
	
	DATA8 col_8
	DATA16 x_16
	DATA16 y_16
	DATA16 w_16
	DATA16 h_16	
	MOVEF_8 col col_8
	MOVEF_16 x x_16
	MOVEF_16 y y_16
	MOVEF_16 w w_16
	MOVEF_16 h h_16
	
	UI_DRAW RECT,col_8,x_16,y_16,w_16,h_16
	
	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW UPDATE
skipupdate:
}

subcall LCD.LINE    // FFFFFV
{
	IN_F col
	IN_F x1
	IN_F y1
	IN_F x2
	IN_F y2	
	
	DATA8 col_8
	DATA16 x1_16
	DATA16 y1_16
	DATA16 x2_16
	DATA16 y2_16		
	MOVEF_8 col col_8
	MOVEF_16 x1 x1_16
	MOVEF_16 y1 y1_16
	MOVEF_16 x2 x2_16
	MOVEF_16 y2 y2_16
	
	UI_DRAW(LINE,col_8,x1_16,y1_16,x2_16,y2_16)
	
	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW UPDATE
skipupdate:
}

subcall LCD.TEXT     // FFFFSV
{
	IN_F col
	IN_F x
	IN_F y
	IN_F font
	IN_S text 252
	
	DATA8 col_8
	DATA16 x_16
	DATA16 y_16
	DATA8 font_8	
	MOVEF_8 col col_8
	MOVEF_16 x x_16
	MOVEF_16 y y_16
	MOVEF_8 font font_8
	
	UI_DRAW SELECT_FONT font_8
	UI_DRAW TEXT col_8 x_16 y_16 text

	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW UPDATE
skipupdate:
}

subcall LCD.CIRCLE     // FFFFV
{
	IN_F col
	IN_F x
	IN_F y
	IN_F r
	
	DATA8 col_8
	DATA16 x_16
	DATA16 y_16
	DATA16 r_16
	MOVEF_8 col col_8
	MOVEF_16 x x_16
	MOVEF_16 y y_16
	MOVEF_16 r r_16
	
	UI_DRAW CIRCLE col_8 x_16 y_16 r_16

	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW UPDATE
skipupdate:
}

subcall LCD.FILLCIRCLE     // FFFFV
{
	IN_F col
	IN_F x
	IN_F y
	IN_F r
	
	DATA8 col_8	
	DATA16 x_16
	DATA16 y_16
	DATA16 r_16

	MOVEF_8 col col_8
	MOVEF_16 x x_16
	MOVEF_16 y y_16
	MOVEF_16 r r_16
	
	UI_DRAW FILLCIRCLE col_8 x_16 y_16 r_16

	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW UPDATE
skipupdate:	
}

subcall LCD.FILLRECT      // FFFFFV
{
	IN_F col
	IN_F x
	IN_F y
	IN_F w
	IN_F h	
	
	DATA8 col_8
	DATA16 x_16
	DATA16 y_16
	DATA16 w_16
	DATA16 h_16	
	MOVEF_8 col col_8
	MOVEF_16 x x_16
	MOVEF_16 y y_16
	MOVEF_16 w w_16
	MOVEF_16 h h_16
	
	UI_DRAW FILLRECT,col_8,x_16,y_16,w_16,h_16
	
	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW UPDATE
skipupdate:
}

subcall LCD.INVERSERECT    // FFFFV
{
	IN_F x
	IN_F y
	IN_F w
	IN_F h	
	
	DATA16 x_16
	DATA16 y_16
	DATA16 w_16
	DATA16 h_16
	
	MOVEF_16 x x_16
	MOVEF_16 y y_16
	MOVEF_16 w w_16
	MOVEF_16 h h_16
	
	UI_DRAW INVERSERECT,x_16,y_16,w_16,h_16

	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW UPDATE
skipupdate:	
}

subcall LCD.PIXEL      // FFFV
{
	IN_F col
	IN_F x
	IN_F y
	
	DATA8 col_8
	DATA16 x_16
	DATA16 y_16	
	MOVEF_8 col col_8
	MOVEF_16 x x_16
	MOVEF_16 y y_16

	UI_DRAW PIXEL,col_8,x_16,y_16

	JR_NEQ32 0 STOPLCDUPDATE skipupdate
	UI_DRAW UPDATE
skipupdate:	
}

// ------------------------------------------ EV3 MODULE: SPEAKER -------------------------------------------------

subcall SPEAKER.STOP      // V
{
	SOUND BREAK
}

subcall SPEAKER.TONE      // FFFV
{
	IN_F volume
	IN_F tone
	IN_F duration
	
	DATA8 vol
	DATA16 tne
	DATA16 dur
	MOVEF_8 volume vol
	MOVEF_16 tone tne
	MOVEF_16 duration dur
	
	SOUND TONE vol tne dur
}

subcall SPEAKER.NOTE      // FSFV
{
	IN_F volume
	IN_S note 8
	IN_F duration
	
	DATA8 vol
	DATA16 tne
	DATA16 dur
	MOVEF_8 volume vol
	NOTE_TO_FREQ note tne
	MOVEF_16 duration dur
	
	SOUND TONE vol tne dur
}

subcall SPEAKER.PLAY    // FSV
{
	IN_F volume
	IN_S filename 252
	
	DATA8 vol 
	MOVEF_8 volume vol
	
	SOUND PLAY vol filename
}

subcall SPEAKER.ISBUSY     // S
{
	OUT_S result 8
	
	DATA8 busy
	SOUND_TEST busy
	JR_EQ8 busy 0 notbusy
	STRINGS DUPLICATE 'True' result
	RETURN
notbusy:
	STRINGS DUPLICATE 'False' result
	RETURN
}

subcall SPEAKER.WAIT     // V
{
	SOUND_READY
}


// ------------------------------------------ EV3 MODULE: BUTTONS -------------------------------------------------

subcall BUTTONS.CURRENT    // S
{
	OUT_S result 8

	DATA8 ispressed
	
	STRINGS DUPLICATE '' result	
	
	UI_BUTTON PRESSED 1 ispressed
	JR_EQ8 ispressed 0 not_up
	STRINGS ADD result 'U' result
not_up:
	UI_BUTTON PRESSED 2 ispressed
	JR_EQ8 ispressed 0 not_enter
	STRINGS ADD result 'E' result
not_enter:
	UI_BUTTON PRESSED 3 ispressed
	JR_EQ8 ispressed 0 not_down
	STRINGS ADD result 'D' result
not_down:	
	UI_BUTTON PRESSED 4 ispressed
	JR_EQ8 ispressed 0 not_right
	STRINGS ADD result 'R' result
not_right:
	UI_BUTTON PRESSED 5 ispressed
	JR_EQ8 ispressed 0 not_left
	STRINGS ADD result 'L' result
not_left:

	RETURN
}

subcall BUTTONS.GETCLICKS      // S
{
	OUT_S result 8

	DATA8 isclicked
	
	STRINGS DUPLICATE '' result	
	
	UI_BUTTON SHORTPRESS 1 isclicked
	JR_EQ8 isclicked 0 not_up
	STRINGS ADD result 'U' result
not_up:
	UI_BUTTON SHORTPRESS 2 isclicked
	JR_EQ8 isclicked 0 not_enter
	STRINGS ADD result 'E' result
not_enter:
	UI_BUTTON SHORTPRESS 3 isclicked
	JR_EQ8 isclicked 0 not_down
	STRINGS ADD result 'D' result
not_down:	
	UI_BUTTON SHORTPRESS 4 isclicked
	JR_EQ8 isclicked 0 not_right
	STRINGS ADD result 'R' result
not_right:
	UI_BUTTON SHORTPRESS 5 isclicked
	JR_EQ8 isclicked 0 not_left
	STRINGS ADD result 'L' result
not_left:	

	RETURN
}

subcall BUTTONS.WAIT        // V
{
	UI_BUTTON WAIT_FOR_PRESS
}

subcall BUTTONS.FLUSH       // V
{
	UI_BUTTON FLUSH
}

// ------------------------------------------ EV3 MODULE: MOTOR ----------------------------------------------

subcall MOTORDECODEPORTSDESCRIPTOR  //  V
{
	IN_S descriptor 8
	OUT_8 layer
	OUT_8 nos

	DATA8 i 
	DATA8 c

	MOVE8_8 0 layer
	MOVE8_8 0 nos	
	MOVE8_8 0 i
loop:
	READ8 descriptor i c
	JR_EQ8 c 0 decoding_end
	
	JR_LT8 c 65 no_uppercase_port
	JR_GT8 c 68 no_uppercase_port
	SUB8 c 65 c
	RL8  1 c c
	OR8  nos c nos
	JR loop_end
no_uppercase_port:
	JR_LT8 c 97 no_lowercase_port
	JR_GT8 c 100 no_lowercase_port
	SUB8 c 97 c
	RL8  1 c c
	OR8  nos c nos	
	JR loop_end
no_lowercase_port:
	JR_LT8 c 48 loop_end
	JR_GT8 c 51 loop_end
	SUB8 c 48 layer
loop_end:
	ADD8 1 i i
	JR loop	
	
decoding_end:
	RETURN
}

subcall MOTORDECODEPORTDESCRIPTOR  //  V
{
	IN_S descriptor 8
	OUT_8 layer
	OUT_8 no

	DATA8 i 
	DATA8 c

	MOVE8_8 0 layer
	MOVE8_8 -1 no
	MOVE8_8 0 i
loop:
	READ8 descriptor i c
	JR_EQ8 c 0 decoding_end
	
	JR_LT8 c 65 no_uppercase_port
	JR_GT8 c 68 no_uppercase_port
	SUB8 c 65 c
	MOVE8_8 c no
	JR loop_end
no_uppercase_port:
	JR_LT8 c 97 no_lowercase_port
	JR_GT8 c 100 no_lowercase_port
	SUB8 c 97 c
	MOVE8_8 c no
	JR loop_end
no_lowercase_port:
	JR_LT8 c 48 loop_end
	JR_GT8 c 51 loop_end
	SUB8 c 48 layer
loop_end:
	ADD8 1 i i
	JR loop	
	
decoding_end:
	RETURN
}

subcall MOTOR.STOP       // SSV      MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_S brake 8

	DATA8 layer
	DATA8 nos	
	DATA8 brk
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	AND8888_32 brake -538976289 brake        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE brake 'TRUE' brk	
	
	OUTPUT_STOP layer nos brk
}

subcall MOTOR.POWER      // SFV     MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F power

	DATA8 layer
	DATA8 nos	
	DATA8 pwr
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_8 power pwr
	JR_LTEQ8 pwr 100 not_too_big
	OUTPUT_POWER layer nos 100
	RETURN
not_too_big:
	JR_GTEQ8 pwr -100 not_too_small
	OUTPUT_POWER layer nos -100
not_too_small:
	OUTPUT_POWER layer nos pwr
}

subcall MOTOR.SPEED      // SFV     MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F speed

	DATA8 layer
	DATA8 nos	
	DATA8 spd
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_8 speed spd
	JR_LTEQ8 spd 100 not_too_big
	OUTPUT_SPEED layer nos 100
	RETURN
not_too_big:
	JR_GTEQ8 spd -100 not_too_small
	OUTPUT_SPEED layer nos -100
not_too_small:
	OUTPUT_SPEED layer nos spd
}

subcall MOTOR.START      // SV     MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8

	DATA8 layer
	DATA8 nos	

	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	OUTPUT_START layer nos
}

subcall MOTOR.GETSPEED // SF      MOTORDECODEPORTDESCRIPTOR
{
	IN_S ports 8
	OUT_F result
	
	DATA8 layer
	DATA8 no
	DATA8 speed
	DATA32 tacho
	
	CALL MOTORDECODEPORTDESCRIPTOR ports layer no
	
	JR_LT8 no 0 no_port
	OUTPUT_READ layer no speed tacho
	MOVE8_F speed result
	RETURN
no_port:
	MOVE8_f 0 result
}

subcall MOTOR.ISBUSY   // SS    MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	OUT_S result 8
	
	DATA8 layer
	DATA8 nos
	DATA8 busy
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos

	OUTPUT_TEST layer nos busy
	JR_EQ8 busy 0 notbusy
	STRINGS DUPLICATE 'True' result
	RETURN
notbusy:
	STRINGS DUPLICATE 'False' result
}

subcall MOTOR.SCHEDULEPOWERFORCOUNT   // SFFFFSV     MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F power
	IN_F step1
	IN_F step2
	IN_F step3
	IN_S brake 8
	
	DATA8 layer
	DATA8 nos
	DATA8 pwr
	DATA32 stp1
	DATA32 stp2
	DATA32 stp3	
	DATA8 brk
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_8 power pwr
	MOVEF_32 step1 stp1
	MOVEF_32 step2 stp2
	MOVEF_32 step3 stp3	
	AND8888_32 brake -538976289 brake        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE brake 'TRUE' brk
	
	OUTPUT_STEP_POWER layer nos pwr stp1 stp2 stp3 brk
}

subcall MOTOR.SchedulePowerForTime   // SFFFFSV      MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F power
	IN_F step1
	IN_F step2
	IN_F step3
	IN_S brake 8
	
	DATA8 layer
	DATA8 nos
	DATA8 pwr
	DATA32 stp1
	DATA32 stp2
	DATA32 stp3	
	DATA8 brk
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_8 power pwr
	MOVEF_32 step1 stp1
	MOVEF_32 step2 stp2
	MOVEF_32 step3 stp3	
	AND8888_32 brake -538976289 brake        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE brake 'TRUE' brk	

	OUTPUT_TIME_POWER layer nos pwr stp1 stp2 stp3 brk
}

subcall MOTOR.ScheduleSpeedForCount   // SFFFFSV    MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F speed
	IN_F step1
	IN_F step2
	IN_F step3
	IN_S brake 8
	
	DATA8 layer
	DATA8 nos
	DATA8 spd
	DATA32 stp1
	DATA32 stp2
	DATA32 stp3	
	DATA8 brk
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_8 speed spd
	MOVEF_32 step1 stp1
	MOVEF_32 step2 stp2
	MOVEF_32 step3 stp3	
	AND8888_32 brake -538976289 brake        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE brake 'TRUE' brk	

	OUTPUT_STEP_SPEED layer nos spd stp1 stp2 stp3 brk
}

subcall MOTOR.ScheduleSpeedForTime   // SFFFFSV    MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F speed
	IN_F step1
	IN_F step2
	IN_F step3
	IN_S brake 8
	
	DATA8 layer
	DATA8 nos
	DATA8 spd
	DATA32 stp1
	DATA32 stp2
	DATA32 stp3	
	DATA8 brk
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_8 speed spd
	MOVEF_32 step1 stp1
	MOVEF_32 step2 stp2
	MOVEF_32 step3 stp3	
	AND8888_32 brake -538976289 brake        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE brake 'TRUE' brk	
	
	OUTPUT_TIME_SPEED layer nos spd stp1 stp2 stp3 brk
}

subcall MOTOR.ScheduleSyncForCount   // SFFFSV    MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F speed
	IN_F turn
	IN_F count
	IN_S brake 8
	
	DATA8 layer
	DATA8 nos
	DATA8 spd
	DATA16 trn
	DATA32 cnt
	DATA8 brk
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_8 speed spd
	MOVEF_16 turn trn
	MOVEF_32 count cnt
	AND8888_32 brake -538976289 brake        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE brake 'TRUE' brk	

	JR_LTEQ32 cnt 0 dontmove	
	OUTPUT_STEP_SYNC layer nos spd trn cnt brk	
dontmove:	
}

subcall MOTOR.ScheduleSyncForTime   // SFFFSV    MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F speed
	IN_F turn
	IN_F time
	IN_S brake 8
	
	DATA8 layer
	DATA8 nos
	DATA8 spd
	DATA16 trn
	DATA32 tim
	DATA8 brk
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_8 speed spd
	MOVEF_16 turn trn
	MOVEF_32 time tim	
	AND8888_32 brake -538976289 brake        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE brake 'TRUE' brk
	
	OUTPUT_TIME_SYNC layer nos spd trn tim brk
}

subcall MOTOR.RESETCOUNT    // SV        MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	
	DATA8 layer
	DATA8 nos
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos

	OUTPUT_CLR_COUNT layer nos
}

subcall MOTOR.GETCOUNT    // SF     MOTORDECODEPORTDESCRIPTOR
{
	IN_S port 8
	OUT_F result
	
	DATA8 layer
	DATA8 no
	DATA32 tacho
	
	CALL MOTORDECODEPORTDESCRIPTOR port layer no
	JR_LT8 no 0 noport
	
	OUTPUT_GET_COUNT layer no tacho
	MOVE32_F tacho result
	RETURN
noport:	
	MOVE8_F 0 result	
}

subcall MOTOR.MOVE     // SFSV   MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8
	IN_F count
	IN_S brake 8

	DATA8 layer
	DATA8 nos
	DATA32 cnt
	DATA8 brk
	
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos
	MOVEF_32 count cnt
	AND8888_32 brake -538976289 brake        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE brake 'TRUE' brk	

	JR_EQ32 cnt 0 dontmove
	JR_LT32 cnt 0 backwards

	OUTPUT_STEP_POWER layer nos 100 0 cnt 0 brk
	OUTPUT_READY layer nos	
	RETURN
	
backwards:
	OUTPUT_STEP_POWER layer nos -100 0 cnt 0 brk
	OUTPUT_READY layer nos
	
dontmove:	
}

subcall MOTOR.WAIT     // SV   MOTORDECODEPORTSDESCRIPTOR
{
	IN_S ports 8

	DATA8 layer
	DATA8 nos
	DATA8 busy
	CALL MOTORDECODEPORTSDESCRIPTOR ports layer nos

waiting:
	OUTPUT_TEST layer nos busy
	JR_EQ8 busy 0 notbusy
	
	DATA32 timer
	TIMER_WAIT 2 timer
	TIMER_READY timer
	JR waiting
	
notbusy:
}

// -------------------------------------------------- EV3 MODULE: SENSOR -----------------------------------

subcall SENSOR.GETNAME		// FS
{
	IN_F port
	OUT_S result 32
	
	DATA8 layer
	DATA8 no
	
	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer
	
	INPUT_DEVICE GET_NAME layer no 32 result
	STRINGS STRIP result result
}

subcall SENSOR.GETTYPE		// FF
{
	IN_F port
	OUT_F result
	
	DATA8 layer
	DATA8 no
	DATA8 type
	DATA8 mode
	
	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer
	
	INPUT_DEVICE GET_TYPEMODE layer no type mode
	MOVE8_F type result
}

subcall SENSOR.GETMODE		// FF
{
	IN_F port
	OUT_F result
	
	DATA8 layer
	DATA8 no
	DATA8 type
	DATA8 mode
	
	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer
	
	INPUT_DEVICE GET_TYPEMODE layer no type mode
	MOVE8_F mode result
}

subcall SENSOR.GETDATAFORMAT    // FS
{
	IN_F port
	OUT_S result 252

	DATA8 layer
	DATA8 no
	DATA8 datasets
	DATA8 format
	DATA8 modes
	DATA8 view
	DATA16 tmp16
	DATAS tmps 20
	
	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer

	INPUT_DEVICE GET_FORMAT layer no datasets format modes view
	
	MOVE8_16 datasets tmp16
	STRINGS NUMBER_TO_STRING tmp16 1 result
	
	MOVE8_16 format tmp16
	STRINGS NUMBER_TO_STRING tmp16 1 tmps	
	STRINGS ADD result ',' result
	STRINGS ADD result tmps result

	MOVE8_16 modes tmp16
	STRINGS NUMBER_TO_STRING tmp16 1 tmps	
	STRINGS ADD result ',' result
	STRINGS ADD result tmps result
}

subcall SENSOR.SETMODE		// FFV
{
	IN_F port
	IN_F mode

	DATA8 layer
	DATA8 no
	DATA8 mode8
	DATA32 dummy
	
	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer
	MOVEF_8 mode mode8
	
	INPUT_DEVICE READY_RAW layer no 0 mode8 0 dummy	
}

subcall SENSOR.ISBUSY       // FS
{
	IN_F port
	OUT_S result 8
	
	DATA8 layer
	DATA8 no
	DATA8 busy
	
	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer

	INPUT_TEST layer no busy
	
	JR_EQ8 busy 0 notbusy
	STRINGS DUPLICATE 'True' result
	RETURN
notbusy:	
	STRINGS DUPLICATE 'False' result
}

subcall SENSOR.WAIT       // FV
{
	IN_F port
	
	DATA8 layer
	DATA8 no
	
	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer

dotest:	
	INPUT_TEST layer no busy
	JR_EQ8 busy 0 notbusy
	INPUT_READY layer no
	JR dotest

notbusy:	
}


subcall SENSOR.READPERCENT       // FF
{
	IN_F port
	OUT_F result

	DATA8 layer
	DATA8 no
	DATA8 percentage

	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer

	INPUT_READ layer no 0 -1 percentage
	JR_LT8 percentage 0 novalue
	
	MOVE8_F percentage result
	RETURN
novalue:	
	MOVE8_F 0 result
}

subcall SENSOR.READRAW            // FF
{
	IN_F port
	OUT_F result
	
	DATA8 layer
	DATA8 no
	
	MOVEF_8 port no
	SUB8 no 1 no
	MOVE8_8 0 layer

	INPUT_READEXT_8 layer no 0 -1 18 8 RAWVALUE0 RAWVALUE1 RAWVALUE2 RAWVALUE3 RAWVALUE4 RAWVALUE5 RAWVALUE6 RAWVALUE7
	
	JR_LT32 RAWVALUE0 0 negative
	MOVE32_F RAWVALUE0 result
	RETURN
negative:
    MOVE32_f 0 result	
}

subcall SENSOR.RAW				// FF
{
	IN_F index
	OUT_F result

	DATA8 idx
	DATA32 raw
	MOVEF_8 index idx
	JR_LT8 idx 1 novalue
	JR_GT8 idx 8 novalue
	SUB8 idx 1 idx
	
	READ32 RAWVALUE0 idx raw
	JR_LT32 raw 0 novalue
	MOVE32_F raw result
	RETURN
novalue:
    MOVE32_f 0 result	
}
