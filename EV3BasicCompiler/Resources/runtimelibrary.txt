
// This method uses the property of the VM, that a subcall can not be 
// re-called by a thread while it is still running in another thread.
// It does an atomic get and increment action, incrementing a counter 
// and returning the original value in a seperate (thread-local) variable
subcall GETANDINC32     // V
{
	IN_32 counterin
	IN_32 inc
	OUT_32 counterout
	OUT_32 prev

	MOVE32_32 counterin prev
	ADD32 counterin inc counterout
}


subcall EQ_STRING       // SSS
{
	IN_S  a 252
	IN_S  b 252
	OUT_S result 8
	
	DATA8 flag
	
	// check if completely equal
	STRINGS COMPARE a b flag
	JR_NEQ8 FLAG 0 isequal
	// second chance: when both values are "True" in any casing, this also counts as equal
	AND8888_32 a -538976289 a        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE a 'TRUE' flag	
	JR_EQ8 0,flag,isnotequal
	AND8888_32 b -538976289 b        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE b 'TRUE' flag	
	JR_EQ8 0,flag,isnotequal
isequal:
	STRINGS DUPLICATE 'True' result
	RETURN
isnotequal:
	STRINGS DUPLICATE 'False' result
	RETURN
}

subcall NE_STRING       // SSS
{
	IN_S  a 252
	IN_S  b 252
	OUT_S result 8
	
	DATA8 flag
	
	// check if completely equal
	STRINGS COMPARE a b flag
	JR_NEQ8 flag 0 isequal
	// second chance: when both values are "True" in any casing, this also counts as equal
	AND8888_32 a -538976289 a        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE a 'TRUE' flag	
	JR_EQ8 0 flag isnotequal
	AND8888_32 b -538976289 b        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE b 'TRUE' flag	
	JR_EQ8 0 flag isnotequal
isequal:
	STRINGS DUPLICATE 'False' result
	RETURN
isnotequal:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall EQ_FLOAT       // FFS
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_EQF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall NE_FLOAT        // FFS
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_NEQF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall LT        // FFS
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_LTF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall GT         // FFS   
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_GTF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall LE        // FFS    
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_LTEQF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall GE        // FFS    
{
	IN_F  a
	IN_F  b
	OUT_S result 8
	
	JR_GTEQF a b istrue
	STRINGS DUPLICATE 'False' result
	RETURN
istrue:
	STRINGS DUPLICATE 'True' result
	RETURN
}

subcall LE_STEP    // FFFS    
// WHEN step>=0  :  result  <- "True" iff a <= b
// ELSE          :  result  <- "True" iff a >= b
{
	IN_F a
	IN_F b
	IN_F step
	OUT_S result 8
	
	JR_LTF step 0.0 negativestep	
	JR_GTF a b deliverfalse
delivertrue:	
	STRINGS DUPLICATE 'True' result	
	RETURN	
negativestep:
	JR_LTEQF b a delivertrue
deliverfalse:
	STRINGS DUPLICATE 'False' result
	RETURN
}

subcall AND		      // SSS
{
	IN_S a 8
	IN_S b 8
	OUT_S result 8
	
	AND8888_32 a -538976289 a        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE a 'TRUE' a	
	JR_EQ8 a 0 deliverfalse	
	AND8888_32 b -538976289 b        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE b 'TRUE' b	
	JR_EQ8 b 0 deliverfalse	
delivertrue:
	STRINGS DUPLICATE 'True' result
	RETURN
deliverfalse:
	STRINGS DUPLICATE 'False' result
}

subcall OR		     // SSS  
{
	IN_S a 8
	IN_S b 8
	OUT_S result 8

	AND8888_32 a -538976289 a        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE a 'TRUE' a	
	JR_NEQ8 a 0 delivertrue	
	AND8888_32 b -538976289 b        // AND 0xdfdfdfdf performs an upcase for 4 letters
    STRINGS COMPARE b 'TRUE' b	
	JR_EQ8 b 0 deliverfalse	
delivertrue:
	STRINGS DUPLICATE 'True' result
	RETURN
deliverfalse:
	STRINGS DUPLICATE 'False' result
}

subcall ARRAYCREATE_FLOAT   // F
{
	OUT_16 handle
	
	ARRAY CREATEF 8 handle			// create with 8 elements
	ARRAY FILL handle 0.0
}

subcall ARRAYSTORE_FLOAT   // FFFV
{
	IN_F index
	IN_F value	
	IN_16 handle
	
	DATA32 index32
	DATA32 len	
	MOVEF_32 index index32

	ARRAY SIZE handle len
	JR_LT32 index32 0 negativeindex
	JR_LT32 index32 len arraybigenough

increasesize:	
	DATA32 doublelen
	ADD32 len len doublelen
	ARRAY RESIZE handle doublelen
writeloop:	
	ARRAY_WRITE handle len 0.0
	ADD32 len 1 len
	JR_LT32 len doublelen writeloop
	JR_GTEQ32 index32 len increasesize
	
arraybigenough:
	ARRAY_WRITE handle index32 value
negativeindex:
}

subcall ARRAYGET_FLOAT     // FFF
{
	IN_F index
	OUT_F value
	IN_16 handle
	
	DATA32 index32
	DATA32 len
	MOVEF_32 index index32
	
	ARRAY SIZE handle len
	JR_LT32 index32 0 outofbounds
	JR_GTEQ32 index32 len outofbounds
	
	ARRAY_READ handle index32 value
	RETURN
outofbounds:
	MOVE8_F 0 value	
}

subcall ARRAYCREATE_STRING   // F
{
	OUT_16 handle

	DATA8 z
	
	ARRAY CREATEF 504  handle     // 504 bytes are enough to store 2 strings
	MOVE8_8 0 z
	ARRAY FILL handle z
}

subcall ARRAYSTORE_STRING   // FFSV
{
	IN_F index
	IN_S value 252	
	IN_16 handle
	
	DATA32 index32
	DATA32 len	
	MOVEF_32 index index32
	MUL32 index32 252 index32
	
	ARRAY SIZE handle len
	JR_LT32 index32 0 negativeindex
	JR_LT32 index32 len arraybigenough

increasesize:	
	DATA32 doublelen
	ADD32 len len doublelen
	ARRAY RESIZE handle doublelen
	DATA8 zerobyte	
	MOVE8_8 0 zerobyte
writeloop:	
	ARRAY_WRITE handle len zerobyte      // only write a 0 at begin of each string (rest does not matter)
	ADD32 len 252 len
	JR_LT32 len doublelen writeloop
	JR_GTEQ32 index32 len increasesize
	
arraybigenough:
	ARRAY WRITE_CONTENT 1 handle index32 252 value
negativeindex:
}
	
subcall ARRAYGET_STRING   // FFS
{
	IN_F index
	OUT_S value 252	
	IN_16 handle

	DATA32 index32
	MOVEF_32 index index32
	
	MUL32 252 index32 index32 // every string has 252 bytes
	MOVE8_8 0 value		  // set to empty string in case that nothing can be read
	
	ARRAY READ_CONTENT 1 handle index32 252 value   // transfer memory from program slot 1
}


